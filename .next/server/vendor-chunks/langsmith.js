"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/langsmith";
exports.ids = ["vendor-chunks/langsmith"];
exports.modules = {

/***/ "(rsc)/./node_modules/langsmith/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/langsmith/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   DEFAULT_BATCH_SIZE_LIMIT_BYTES: () => (/* binding */ DEFAULT_BATCH_SIZE_LIMIT_BYTES),\n/* harmony export */   Queue: () => (/* binding */ Queue)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/messages.js */ \"(rsc)/./node_modules/langsmith/dist/utils/messages.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n\n\n\n\n\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n    const runtimeEnv = await (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironment)();\n    const envVars = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangChainEnvVarsMetadata)();\n    return runs.map((run)=>{\n        const extra = run.extra ?? {};\n        const metadata = extra.metadata;\n        run.extra = {\n            ...extra,\n            runtime: {\n                ...runtimeEnv,\n                ...extra?.runtime\n            },\n            metadata: {\n                ...envVars,\n                ...envVars.revision_id || run.revision_id ? {\n                    revision_id: run.revision_id ?? envVars.revision_id\n                } : {},\n                ...metadata\n            }\n        };\n        return run;\n    });\n}\nconst getTracingSamplingRate = ()=>{\n    const samplingRateStr = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url)=>{\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nconst raiseForStatus = async (response, operation)=>{\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    const body = await response.text();\n    if (!response.ok) {\n        throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n    }\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable){\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n    if (!uuid__WEBPACK_IMPORTED_MODULE_4__[\"default\"](str)) {\n        throw new Error(`Invalid UUID: ${str}`);\n    }\n}\nconst handle429 = async (response)=>{\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve)=>setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nclass Queue {\n    constructor(){\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    get size() {\n        return this.items.length;\n    }\n    push(item) {\n        // this.items.push is synchronous with promise creation:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n        return new Promise((resolve)=>{\n            this.items.push([\n                item,\n                resolve\n            ]);\n        });\n    }\n    pop(upToN) {\n        if (upToN < 1) {\n            throw new Error(\"Number of items to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        while(popped.length < upToN && this.items.length){\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n            } else {\n                break;\n            }\n        }\n        return [\n            popped.map((it)=>it[0]),\n            ()=>popped.forEach((it)=>it[1]())\n        ];\n    }\n}\n// 20 MB\nconst DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;\nclass Client {\n    constructor(config = {}){\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sampledPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"batchEndpointSupported\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Queue()\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 100\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        Object.defineProperty(this, \"serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        this.timeout_ms = config.timeout_ms ?? 12000;\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller(config.callerOptions ?? {});\n        this.batchIngestCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller({\n            ...config.callerOptions ?? {},\n            onFailedResponseHook: handle429\n        });\n        this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.pendingAutoBatchedRunLimit = config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n    }\n    static getDefaultClientConfig() {\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\");\n        const apiUrl = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"https://api.smith.langchain.com\";\n        const hideInputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n        const hideOutputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        } else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost\";\n            return \"http://localhost\";\n        } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return \"https://dev.smith.langchain.com\";\n        } else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return \"https://smith.langchain.com\";\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${_index_js__WEBPACK_IMPORTED_MODULE_3__.__version__}`\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = {\n            ...run\n        };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams()) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while(true){\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(fetch, url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms)\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n            }\n            const items = await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? {\n            ...body\n        } : {};\n        while(true){\n            const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                body: JSON.stringify(bodyParams)\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs){\n                if (this.sampledPostUuids.has(run.id)) {\n                    sampled.push(run);\n                    this.sampledPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        } else {\n            const sampled = [];\n            for (const run of runs){\n                if (Math.random() < this.tracingSampleRate) {\n                    sampled.push(run);\n                    this.sampledPostUuids.add(run.id);\n                }\n            }\n            return sampled;\n        }\n    }\n    async drainAutoBatchQueue() {\n        while(this.autoBatchQueue.size >= 0){\n            const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);\n            if (!batch.length) {\n                done();\n                return;\n            }\n            try {\n                await this.batchIngestRuns({\n                    runCreates: batch.filter((item)=>item.action === \"create\").map((item)=>item.item),\n                    runUpdates: batch.filter((item)=>item.action === \"update\").map((item)=>item.item)\n                });\n            } finally{\n                done();\n            }\n        }\n    }\n    async processRunOperation(item, immediatelyTriggerBatch) {\n        const oldTimeout = this.autoBatchTimeout;\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (immediatelyTriggerBatch || this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {\n            await this.drainAutoBatchQueue();\n        }\n        if (this.autoBatchQueue.size > 0) {\n            this.autoBatchTimeout = setTimeout(()=>{\n                this.autoBatchTimeout = undefined;\n                // This error would happen in the background and is uncatchable\n                // from the outside. So just log instead.\n                void this.drainAutoBatchQueue().catch(console.error);\n            }, oldTimeout ? this.autoBatchAggregationDelayMs : this.autoBatchInitialDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await fetch(`${this.apiUrl}/info`, {\n            method: \"GET\",\n            headers: {\n                Accept: \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            // consume the response body to release the connection\n            // https://undici.nodejs.org/#/?id=garbage-collection\n            await response.text();\n            throw new Error(\"Failed to retrieve server info.\");\n        }\n        return response.json();\n    }\n    async batchEndpointIsSupported() {\n        try {\n            this.serverInfo = await this._getServerInfo();\n        } catch (e) {\n            return false;\n        }\n        return true;\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([\n            run\n        ]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now()\n        });\n        if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([\n            runCreate\n        ]);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(mergedRunCreateParams[0]),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"create run\");\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */ async batchIngestRuns({ runCreates, runUpdates }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create)=>this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update)=>this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run)=>{\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams){\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam\n                    };\n                } else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: this._filterForSampling(preparedCreateParams),\n            patch: this._filterForSampling(preparedUpdateParams, true)\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n        if (this.batchEndpointSupported === undefined) {\n            this.batchEndpointSupported = await this.batchEndpointIsSupported();\n        }\n        if (!this.batchEndpointSupported) {\n            this.autoBatchTracing = false;\n            for (const preparedCreateParam of rawBatch.post){\n                await this.createRun(preparedCreateParam);\n            }\n            for (const preparedUpdateParam of rawBatch.patch){\n                if (preparedUpdateParam.id !== undefined) {\n                    await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n                }\n            }\n            return;\n        }\n        const sizeLimitBytes = this.serverInfo?.batch_ingest_config?.size_limit_bytes ?? DEFAULT_BATCH_SIZE_LIMIT_BYTES;\n        const batchChunks = {\n            post: [],\n            patch: []\n        };\n        let currentBatchSizeBytes = 0;\n        for (const k of [\n            \"post\",\n            \"patch\"\n        ]){\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while(batchItem !== undefined){\n                const stringifiedBatchItem = JSON.stringify(batchItem);\n                if (currentBatchSizeBytes > 0 && currentBatchSizeBytes + stringifiedBatchItem.length > sizeLimitBytes) {\n                    await this._postBatchIngestRuns(JSON.stringify(batchChunks));\n                    currentBatchSizeBytes = 0;\n                    batchChunks.post = [];\n                    batchChunks.patch = [];\n                }\n                currentBatchSizeBytes += stringifiedBatchItem.length;\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            await this._postBatchIngestRuns(JSON.stringify(batchChunks));\n        }\n    }\n    async _postBatchIngestRuns(body) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\"\n        };\n        const response = await this.batchIngestCaller.call(fetch, `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: body,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"batch create run\");\n    }\n    async updateRun(runId, run) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = {\n            ...run,\n            id: runId\n        };\n        if (!this._filterForSampling([\n            data\n        ], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n            if (run.end_time !== undefined && data.parent_run_id === undefined) {\n                // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({\n                    action: \"update\",\n                    item: data\n                }, true);\n                return;\n            } else {\n                void this.processRunOperation({\n                    action: \"update\",\n                    item: data\n                }).catch(console.error);\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: JSON.stringify(run),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"update run\");\n    }\n    async readRun(runId, { loadChildRuns } = {\n        loadChildRuns: false\n    }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            } else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({\n                    projectName: projectOpts?.projectName\n                })).id;\n            } else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            } else {\n                const project = await this.readProject({\n                    projectName: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") || \"default\"\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        } else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        } else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            id: run.child_run_ids\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b)=>(a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns){\n            if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for(const runId in treemap){\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param executionOrder - The execution order to filter by.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */ async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, runType, error, id, query, filter, traceFilter, treeFilter, limit } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [\n                projectId\n            ];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName) ? projectName : [\n                projectName\n            ];\n            const projectIds_ = await Promise.all(projectNames.map((name)=>this.readProject({\n                    projectName: name\n                }).then((project)=>project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId\n        };\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)){\n            yield* runs;\n        }\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"]()\n        };\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"unshare run\");\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds){\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId\n        };\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"unshare dataset\");\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = {\n                ...extra || {},\n                metadata\n            };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null\n        };\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async hasProject({ projectId, projectName }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}${path}?${params}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({\n            limit: \"1\"\n        });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)){\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds){\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        } else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)){\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        } else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId === undefined) {\n            projectId_ = (await this.readProject({\n                projectName\n            })).id;\n        } else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key)=>{\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key)=>{\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${fileName} already exists`);\n            }\n            throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType } = {}) {\n        const body = {\n            name,\n            description\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${name} already exists`);\n            }\n            throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({\n            limit: \"1\"\n        });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        } else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\" ? fromVersion : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString()\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n        // do nothing\n        } else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({\n                datasetName\n            })).id;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText.trim().split(\"\\n\").map((line)=>JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString()\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds){\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of this._getPaginated(path, params)){\n            yield* datasets;\n        }\n    }\n    async deleteDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_?.toISOString(),\n            id: exampleId\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createExamples(props) {\n        const { inputs, outputs, sourceRunIds, exampleIds, datasetId, datasetName } = props;\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx)=>{\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs ? outputs[idx] : undefined,\n                id: exampleIds ? exampleIds[idx] : undefined,\n                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined\n            };\n        });\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(formattedExamples),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({\n            input\n        }, {\n            output: generation\n        }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message)=>{\n            if ((0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(message)) {\n                return (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(message);\n            }\n            return message;\n        });\n        const finalOutput = (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(generations) ? (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(generations) : generations;\n        return this.createExample({\n            input: finalInput\n        }, {\n            output: finalOutput\n        }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, inlineS3Urls } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({\n            dataset: datasetId_\n        });\n        const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds){\n                params.append(\"id\", id_);\n            }\n        }\n        for await (const examples of this._getPaginated(\"/examples\", params)){\n            yield* examples;\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        assertUuid(exampleId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = {\n        loadChildRuns: false\n    }) {\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, {\n                loadChildRuns\n            });\n        } else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        } else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        let sourceInfo_ = sourceInfo ?? {};\n        if (feedbackResult.evaluatorInfo) {\n            sourceInfo_ = {\n                ...sourceInfo_,\n                ...feedbackResult.evaluatorInfo\n            };\n        }\n        const runId = feedbackResult.targetRunId ?? run_.id;\n        return await this.createFeedback(runId, feedbackResult.key, {\n            score: feedbackResult?.score,\n            value: feedbackResult?.value,\n            comment: feedbackResult?.comment,\n            correction: feedbackResult?.correction,\n            sourceInfo: sourceInfo_,\n            feedbackSourceType: \"model\",\n            sourceRunId: feedbackResult?.sourceRunId\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig }) {\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {}\n        };\n        if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = {\n                run_id: sourceRunId\n            };\n        }\n        if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"](),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            feedbackConfig\n        };\n        const url = `${this.apiUrl}/feedback`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"create feedback\");\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"update feedback\");\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys){\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes){\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)){\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId - The ID of the run.\n     * @param feedbackKey - The feedback key.\n     * @param options - Additional options for the token.\n     * @param options.expiration - The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */ async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            } else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        } else {\n            body[\"expires_in\"] = {\n                hours: 3\n            };\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/tokens`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        return result;\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */ async *listPresignedFeedbackTokens(runId) {\n        assertUuid(runId);\n        const params = new URLSearchParams({\n            run_id: runId\n        });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)){\n            yield* tokens;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE2QjtBQUN5QjtBQUNzQztBQUNpQjtBQUNwRTtBQUN6QyxlQUFlUSw4QkFBOEJDLElBQUk7SUFDN0MsTUFBTUMsYUFBYSxNQUFNSixvRUFBcUJBO0lBQzlDLE1BQU1LLFVBQVVOLDBFQUEyQkE7SUFDM0MsT0FBT0ksS0FBS0csR0FBRyxDQUFDLENBQUNDO1FBQ2IsTUFBTUMsUUFBUUQsSUFBSUMsS0FBSyxJQUFJLENBQUM7UUFDNUIsTUFBTUMsV0FBV0QsTUFBTUMsUUFBUTtRQUMvQkYsSUFBSUMsS0FBSyxHQUFHO1lBQ1IsR0FBR0EsS0FBSztZQUNSRSxTQUFTO2dCQUNMLEdBQUdOLFVBQVU7Z0JBQ2IsR0FBR0ksT0FBT0UsT0FBTztZQUNyQjtZQUNBRCxVQUFVO2dCQUNOLEdBQUdKLE9BQU87Z0JBQ1YsR0FBSUEsUUFBUU0sV0FBVyxJQUFJSixJQUFJSSxXQUFXLEdBQ3BDO29CQUFFQSxhQUFhSixJQUFJSSxXQUFXLElBQUlOLFFBQVFNLFdBQVc7Z0JBQUMsSUFDdEQsQ0FBQyxDQUFDO2dCQUNSLEdBQUdGLFFBQVE7WUFDZjtRQUNKO1FBQ0EsT0FBT0Y7SUFDWDtBQUNKO0FBQ0EsTUFBTUsseUJBQXlCO0lBQzNCLE1BQU1DLGtCQUFrQmYscUVBQXNCQSxDQUFDO0lBQy9DLElBQUllLG9CQUFvQkMsV0FBVztRQUMvQixPQUFPQTtJQUNYO0lBQ0EsTUFBTUMsZUFBZUMsV0FBV0g7SUFDaEMsSUFBSUUsZUFBZSxLQUFLQSxlQUFlLEdBQUc7UUFDdEMsTUFBTSxJQUFJRSxNQUFNLENBQUMscUVBQXFFLEVBQUVGLGFBQWEsQ0FBQztJQUMxRztJQUNBLE9BQU9BO0FBQ1g7QUFDQSxvQkFBb0I7QUFDcEIsTUFBTUcsY0FBYyxDQUFDQztJQUNqQixNQUFNQyxjQUFjRCxJQUFJRSxPQUFPLENBQUMsV0FBVyxJQUFJQSxPQUFPLENBQUMsWUFBWTtJQUNuRSxNQUFNQyxXQUFXRixZQUFZRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0lBQ3hELE9BQVFELGFBQWEsZUFBZUEsYUFBYSxlQUFlQSxhQUFhO0FBQ2pGO0FBQ0EsTUFBTUUsaUJBQWlCLE9BQU9DLFVBQVVDO0lBQ3BDLHNEQUFzRDtJQUN0RCxxREFBcUQ7SUFDckQsTUFBTUMsT0FBTyxNQUFNRixTQUFTRyxJQUFJO0lBQ2hDLElBQUksQ0FBQ0gsU0FBU0ksRUFBRSxFQUFFO1FBQ2QsTUFBTSxJQUFJWixNQUFNLENBQUMsVUFBVSxFQUFFUyxVQUFVLEVBQUUsRUFBRUQsU0FBU0ssTUFBTSxDQUFDLENBQUMsRUFBRUwsU0FBU00sVUFBVSxDQUFDLENBQUMsRUFBRUosS0FBSyxDQUFDO0lBQy9GO0FBQ0o7QUFDQSxlQUFlSyxRQUFRQyxRQUFRO0lBQzNCLE1BQU1DLFNBQVMsRUFBRTtJQUNqQixXQUFXLE1BQU1DLFFBQVFGLFNBQVU7UUFDL0JDLE9BQU9FLElBQUksQ0FBQ0Q7SUFDaEI7SUFDQSxPQUFPRDtBQUNYO0FBQ0EsU0FBU0csV0FBV0MsR0FBRztJQUNuQixJQUFJQSxRQUFReEIsV0FBVztRQUNuQixPQUFPQTtJQUNYO0lBQ0EsT0FBT3dCLElBQ0ZDLElBQUksR0FDSmxCLE9BQU8sQ0FBQyxZQUFZLE1BQ3BCQSxPQUFPLENBQUMsWUFBWTtBQUM3QjtBQUNBLFNBQVNtQixXQUFXRixHQUFHO0lBQ25CLElBQUksQ0FBQzVDLDRDQUFhLENBQUM0QyxNQUFNO1FBQ3JCLE1BQU0sSUFBSXJCLE1BQU0sQ0FBQyxjQUFjLEVBQUVxQixJQUFJLENBQUM7SUFDMUM7QUFDSjtBQUNBLE1BQU1JLFlBQVksT0FBT2pCO0lBQ3JCLElBQUlBLFVBQVVLLFdBQVcsS0FBSztRQUMxQixNQUFNYSxhQUFhQyxTQUFTbkIsU0FBU29CLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGtCQUFrQixNQUFNLE1BQU07UUFDL0UsSUFBSUgsYUFBYSxHQUFHO1lBQ2hCLE1BQU0sSUFBSUksUUFBUSxDQUFDQyxVQUFZQyxXQUFXRCxTQUFTTDtZQUNuRCwyQ0FBMkM7WUFDM0MsT0FBTztRQUNYO0lBQ0o7SUFDQSxzQ0FBc0M7SUFDdEMsT0FBTztBQUNYO0FBQ08sTUFBTU87SUFDVEMsYUFBYztRQUNWQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sRUFBRTtRQUNiO0lBQ0o7SUFDQSxJQUFJQyxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsTUFBTTtJQUM1QjtJQUNBeEIsS0FBS0QsSUFBSSxFQUFFO1FBQ1Asd0RBQXdEO1FBQ3hELG1HQUFtRztRQUNuRyxPQUFPLElBQUlZLFFBQVEsQ0FBQ0M7WUFDaEIsSUFBSSxDQUFDVyxLQUFLLENBQUN2QixJQUFJLENBQUM7Z0JBQUNEO2dCQUFNYTthQUFRO1FBQ25DO0lBQ0o7SUFDQWEsSUFBSUMsS0FBSyxFQUFFO1FBQ1AsSUFBSUEsUUFBUSxHQUFHO1lBQ1gsTUFBTSxJQUFJN0MsTUFBTTtRQUNwQjtRQUNBLE1BQU04QyxTQUFTLEVBQUU7UUFDakIsTUFBT0EsT0FBT0gsTUFBTSxHQUFHRSxTQUFTLElBQUksQ0FBQ0gsS0FBSyxDQUFDQyxNQUFNLENBQUU7WUFDL0MsTUFBTXpCLE9BQU8sSUFBSSxDQUFDd0IsS0FBSyxDQUFDSyxLQUFLO1lBQzdCLElBQUk3QixNQUFNO2dCQUNONEIsT0FBTzNCLElBQUksQ0FBQ0Q7WUFDaEIsT0FDSztnQkFDRDtZQUNKO1FBQ0o7UUFDQSxPQUFPO1lBQUM0QixPQUFPekQsR0FBRyxDQUFDLENBQUMyRCxLQUFPQSxFQUFFLENBQUMsRUFBRTtZQUFHLElBQU1GLE9BQU9HLE9BQU8sQ0FBQyxDQUFDRCxLQUFPQSxFQUFFLENBQUMsRUFBRTtTQUFJO0lBQzdFO0FBQ0o7QUFDQSxRQUFRO0FBQ0QsTUFBTUUsaUNBQWlDLFNBQVM7QUFDaEQsTUFBTUM7SUFDVGpCLFlBQVlrQixTQUFTLENBQUMsQ0FBQyxDQUFFO1FBQ3JCakIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxVQUFVO1lBQ2xDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxVQUFVO1lBQ2xDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxVQUFVO1lBQ2xDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxVQUFVO1lBQ2xDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxxQkFBcUI7WUFDN0NDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGFBQWE7WUFDckNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU87UUFDWDtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGVBQWU7WUFDdkNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLHFCQUFxQjtZQUM3Q0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsb0JBQW9CO1lBQzVDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLElBQUlhO1FBQ2Y7UUFDQWxCLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsb0JBQW9CO1lBQzVDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSwwQkFBMEI7WUFDbERDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGtCQUFrQjtZQUMxQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxJQUFJUDtRQUNmO1FBQ0FFLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsOEJBQThCO1lBQ3REQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxvQkFBb0I7WUFDNUNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLDJCQUEyQjtZQUNuREMsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTztRQUNYO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsK0JBQStCO1lBQ3ZEQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxjQUFjO1lBQ3RDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQSxNQUFNYyxnQkFBZ0JILE9BQU9JLHNCQUFzQjtRQUNuRCxJQUFJLENBQUNDLGlCQUFpQixHQUFHN0Q7UUFDekIsSUFBSSxDQUFDOEQsTUFBTSxHQUFHckMsV0FBV2dDLE9BQU9LLE1BQU0sSUFBSUgsY0FBY0csTUFBTSxLQUFLO1FBQ25FLElBQUksQ0FBQ0MsTUFBTSxHQUFHdEMsV0FBV2dDLE9BQU9NLE1BQU0sSUFBSUosY0FBY0ksTUFBTTtRQUM5RCxJQUFJLENBQUNDLE1BQU0sR0FBR3ZDLFdBQVdnQyxPQUFPTyxNQUFNLElBQUlMLGNBQWNLLE1BQU07UUFDOUQsSUFBSSxDQUFDQyxVQUFVLEdBQUdSLE9BQU9RLFVBQVUsSUFBSTtRQUN2QyxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJbkYsK0RBQVdBLENBQUMwRSxPQUFPVSxhQUFhLElBQUksQ0FBQztRQUN2RCxJQUFJLENBQUNDLGlCQUFpQixHQUFHLElBQUlyRiwrREFBV0EsQ0FBQztZQUNyQyxHQUFJMEUsT0FBT1UsYUFBYSxJQUFJLENBQUMsQ0FBQztZQUM5QkUsc0JBQXNCdkM7UUFDMUI7UUFDQSxJQUFJLENBQUN3QyxVQUFVLEdBQUdiLE9BQU9hLFVBQVUsSUFBSVgsY0FBY1csVUFBVTtRQUMvRCxJQUFJLENBQUNDLFdBQVcsR0FBR2QsT0FBT2MsV0FBVyxJQUFJWixjQUFjWSxXQUFXO1FBQ2xFLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdmLE9BQU9lLGdCQUFnQixJQUFJLElBQUksQ0FBQ0EsZ0JBQWdCO1FBQ3hFLElBQUksQ0FBQ0MsMEJBQTBCLEdBQzNCaEIsT0FBT2dCLDBCQUEwQixJQUFJLElBQUksQ0FBQ0EsMEJBQTBCO0lBQzVFO0lBQ0EsT0FBT2IseUJBQXlCO1FBQzVCLE1BQU1HLFNBQVM3RSxxRUFBc0JBLENBQUM7UUFDdEMsTUFBTTRFLFNBQVM1RSxxRUFBc0JBLENBQUMseUJBQ2xDO1FBQ0osTUFBTW9GLGFBQWFwRixxRUFBc0JBLENBQUMsNkJBQTZCO1FBQ3ZFLE1BQU1xRixjQUFjckYscUVBQXNCQSxDQUFDLDhCQUE4QjtRQUN6RSxPQUFPO1lBQ0g0RSxRQUFRQTtZQUNSQyxRQUFRQTtZQUNSQyxRQUFROUQ7WUFDUm9FLFlBQVlBO1lBQ1pDLGFBQWFBO1FBQ2pCO0lBQ0o7SUFDQUcsYUFBYTtRQUNULElBQUksSUFBSSxDQUFDVixNQUFNLEVBQUU7WUFDYixPQUFPLElBQUksQ0FBQ0EsTUFBTTtRQUN0QixPQUNLLElBQUkxRCxZQUFZLElBQUksQ0FBQ3dELE1BQU0sR0FBRztZQUMvQixJQUFJLENBQUNFLE1BQU0sR0FBRztZQUNkLE9BQU87UUFDWCxPQUNLLElBQUksSUFBSSxDQUFDRixNQUFNLENBQUNhLFFBQVEsQ0FBQyxXQUMxQixDQUFDLElBQUksQ0FBQ2IsTUFBTSxDQUFDbkQsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQ2lFLFFBQVEsQ0FBQyxRQUFRO1lBQy9DLElBQUksQ0FBQ1osTUFBTSxHQUFHLElBQUksQ0FBQ0YsTUFBTSxDQUFDckQsT0FBTyxDQUFDLFFBQVE7WUFDMUMsT0FBTyxJQUFJLENBQUN1RCxNQUFNO1FBQ3RCLE9BQ0ssSUFBSSxJQUFJLENBQUNGLE1BQU0sQ0FBQ25ELEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUNnRSxRQUFRLENBQUMsUUFBUTtZQUNuRCxJQUFJLENBQUNYLE1BQU0sR0FBRztZQUNkLE9BQU87UUFDWCxPQUNLO1lBQ0QsSUFBSSxDQUFDQSxNQUFNLEdBQUc7WUFDZCxPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUkvQixVQUFVO1FBQ1YsTUFBTUEsVUFBVTtZQUNaLGNBQWMsQ0FBQyxhQUFhLEVBQUU1QyxrREFBV0EsQ0FBQyxDQUFDO1FBQy9DO1FBQ0EsSUFBSSxJQUFJLENBQUMwRSxNQUFNLEVBQUU7WUFDYjlCLE9BQU8sQ0FBQyxZQUFZLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQzhCLE1BQU0sQ0FBQyxDQUFDO1FBQzNDO1FBQ0EsT0FBTzlCO0lBQ1g7SUFDQTRDLGNBQWNDLE1BQU0sRUFBRTtRQUNsQixJQUFJLElBQUksQ0FBQ1IsVUFBVSxLQUFLLE9BQU87WUFDM0IsT0FBT1E7UUFDWDtRQUNBLElBQUksSUFBSSxDQUFDUixVQUFVLEtBQUssTUFBTTtZQUMxQixPQUFPLENBQUM7UUFDWjtRQUNBLElBQUksT0FBTyxJQUFJLENBQUNBLFVBQVUsS0FBSyxZQUFZO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDQSxVQUFVLENBQUNRO1FBQzNCO1FBQ0EsT0FBT0E7SUFDWDtJQUNBQyxlQUFlQyxPQUFPLEVBQUU7UUFDcEIsSUFBSSxJQUFJLENBQUNULFdBQVcsS0FBSyxPQUFPO1lBQzVCLE9BQU9TO1FBQ1g7UUFDQSxJQUFJLElBQUksQ0FBQ1QsV0FBVyxLQUFLLE1BQU07WUFDM0IsT0FBTyxDQUFDO1FBQ1o7UUFDQSxJQUFJLE9BQU8sSUFBSSxDQUFDQSxXQUFXLEtBQUssWUFBWTtZQUN4QyxPQUFPLElBQUksQ0FBQ0EsV0FBVyxDQUFDUztRQUM1QjtRQUNBLE9BQU9BO0lBQ1g7SUFDQUMsK0JBQStCdEYsR0FBRyxFQUFFO1FBQ2hDLE1BQU11RixZQUFZO1lBQUUsR0FBR3ZGLEdBQUc7UUFBQztRQUMzQixJQUFJdUYsVUFBVUosTUFBTSxLQUFLNUUsV0FBVztZQUNoQ2dGLFVBQVVKLE1BQU0sR0FBRyxJQUFJLENBQUNELGFBQWEsQ0FBQ0ssVUFBVUosTUFBTTtRQUMxRDtRQUNBLElBQUlJLFVBQVVGLE9BQU8sS0FBSzlFLFdBQVc7WUFDakNnRixVQUFVRixPQUFPLEdBQUcsSUFBSSxDQUFDRCxjQUFjLENBQUNHLFVBQVVGLE9BQU87UUFDN0Q7UUFDQSxPQUFPRTtJQUNYO0lBQ0EsTUFBTUMsYUFBYUMsSUFBSSxFQUFFQyxXQUFXLEVBQUU7UUFDbEMsTUFBTUMsZUFBZUQsYUFBYUUsY0FBYztRQUNoRCxNQUFNaEYsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDdUQsTUFBTSxDQUFDLEVBQUVzQixLQUFLLENBQUMsRUFBRUUsYUFBYSxDQUFDO1FBQ25ELE1BQU16RSxXQUFXLE1BQU0sSUFBSSxDQUFDcUQsTUFBTSxDQUFDc0IsSUFBSSxDQUFDQyxPQUFPbEYsS0FBSztZQUNoRG1GLFFBQVE7WUFDUnpELFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCMEQsUUFBUUMsWUFBWUMsT0FBTyxDQUFDLElBQUksQ0FBQzVCLFVBQVU7UUFDL0M7UUFDQSxJQUFJLENBQUNwRCxTQUFTSSxFQUFFLEVBQUU7WUFDZCxNQUFNLElBQUlaLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRStFLEtBQUssRUFBRSxFQUFFdkUsU0FBU0ssTUFBTSxDQUFDLENBQUMsRUFBRUwsU0FBU00sVUFBVSxDQUFDLENBQUM7UUFDeEY7UUFDQSxPQUFPTjtJQUNYO0lBQ0EsTUFBTWlGLEtBQUtWLElBQUksRUFBRUMsV0FBVyxFQUFFO1FBQzFCLE1BQU14RSxXQUFXLE1BQU0sSUFBSSxDQUFDc0UsWUFBWSxDQUFDQyxNQUFNQztRQUMvQyxPQUFPeEUsU0FBU2tGLElBQUk7SUFDeEI7SUFDQSxPQUFPQyxjQUFjWixJQUFJLEVBQUVDLGNBQWMsSUFBSVksaUJBQWlCLEVBQUU7UUFDNUQsSUFBSUMsU0FBU0MsT0FBT2QsWUFBWW5ELEdBQUcsQ0FBQyxjQUFjO1FBQ2xELE1BQU1rRSxRQUFRRCxPQUFPZCxZQUFZbkQsR0FBRyxDQUFDLGFBQWE7UUFDbEQsTUFBTyxLQUFNO1lBQ1RtRCxZQUFZZ0IsR0FBRyxDQUFDLFVBQVVDLE9BQU9KO1lBQ2pDYixZQUFZZ0IsR0FBRyxDQUFDLFNBQVNDLE9BQU9GO1lBQ2hDLE1BQU03RixNQUFNLENBQUMsRUFBRSxJQUFJLENBQUN1RCxNQUFNLENBQUMsRUFBRXNCLEtBQUssQ0FBQyxFQUFFQyxZQUFZLENBQUM7WUFDbEQsTUFBTXhFLFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU9sRixLQUFLO2dCQUNoRG1GLFFBQVE7Z0JBQ1J6RCxTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckIwRCxRQUFRQyxZQUFZQyxPQUFPLENBQUMsSUFBSSxDQUFDNUIsVUFBVTtZQUMvQztZQUNBLElBQUksQ0FBQ3BELFNBQVNJLEVBQUUsRUFBRTtnQkFDZCxNQUFNLElBQUlaLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRStFLEtBQUssRUFBRSxFQUFFdkUsU0FBU0ssTUFBTSxDQUFDLENBQUMsRUFBRUwsU0FBU00sVUFBVSxDQUFDLENBQUM7WUFDeEY7WUFDQSxNQUFNNEIsUUFBUSxNQUFNbEMsU0FBU2tGLElBQUk7WUFDakMsSUFBSWhELE1BQU1DLE1BQU0sS0FBSyxHQUFHO2dCQUNwQjtZQUNKO1lBQ0EsTUFBTUQ7WUFDTixJQUFJQSxNQUFNQyxNQUFNLEdBQUdvRCxPQUFPO2dCQUN0QjtZQUNKO1lBQ0FGLFVBQVVuRCxNQUFNQyxNQUFNO1FBQzFCO0lBQ0o7SUFDQSxPQUFPdUQsd0JBQXdCbkIsSUFBSSxFQUFFckUsT0FBTyxJQUFJLEVBQUV5RixnQkFBZ0IsTUFBTSxFQUFFQyxVQUFVLE1BQU0sRUFBRTtRQUN4RixNQUFNQyxhQUFhM0YsT0FBTztZQUFFLEdBQUdBLElBQUk7UUFBQyxJQUFJLENBQUM7UUFDekMsTUFBTyxLQUFNO1lBQ1QsTUFBTUYsV0FBVyxNQUFNLElBQUksQ0FBQ3FELE1BQU0sQ0FBQ3NCLElBQUksQ0FBQ0MsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDM0IsTUFBTSxDQUFDLEVBQUVzQixLQUFLLENBQUMsRUFBRTtnQkFDcEVNLFFBQVFjO2dCQUNSdkUsU0FBUztvQkFBRSxHQUFHLElBQUksQ0FBQ0EsT0FBTztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUMvRDBELFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO2dCQUMzQ2xELE1BQU00RixLQUFLQyxTQUFTLENBQUNGO1lBQ3pCO1lBQ0EsTUFBTUcsZUFBZSxNQUFNaEcsU0FBU2tGLElBQUk7WUFDeEMsSUFBSSxDQUFDYyxjQUFjO2dCQUNmO1lBQ0o7WUFDQSxJQUFJLENBQUNBLFlBQVksQ0FBQ0osUUFBUSxFQUFFO2dCQUN4QjtZQUNKO1lBQ0EsTUFBTUksWUFBWSxDQUFDSixRQUFRO1lBQzNCLE1BQU1LLFVBQVVELGFBQWFDLE9BQU87WUFDcEMsSUFBSSxDQUFDQSxTQUFTO2dCQUNWO1lBQ0o7WUFDQSxJQUFJLENBQUNBLFFBQVFDLElBQUksRUFBRTtnQkFDZjtZQUNKO1lBQ0FMLFdBQVdNLE1BQU0sR0FBR0YsUUFBUUMsSUFBSTtRQUNwQztJQUNKO0lBQ0FFLG1CQUFtQjFILElBQUksRUFBRTJILFFBQVEsS0FBSyxFQUFFO1FBQ3BDLElBQUksSUFBSSxDQUFDckQsaUJBQWlCLEtBQUszRCxXQUFXO1lBQ3RDLE9BQU9YO1FBQ1g7UUFDQSxJQUFJMkgsT0FBTztZQUNQLE1BQU1DLFVBQVUsRUFBRTtZQUNsQixLQUFLLE1BQU14SCxPQUFPSixLQUFNO2dCQUNwQixJQUFJLElBQUksQ0FBQzZILGdCQUFnQixDQUFDQyxHQUFHLENBQUMxSCxJQUFJMkgsRUFBRSxHQUFHO29CQUNuQ0gsUUFBUTNGLElBQUksQ0FBQzdCO29CQUNiLElBQUksQ0FBQ3lILGdCQUFnQixDQUFDRyxNQUFNLENBQUM1SCxJQUFJMkgsRUFBRTtnQkFDdkM7WUFDSjtZQUNBLE9BQU9IO1FBQ1gsT0FDSztZQUNELE1BQU1BLFVBQVUsRUFBRTtZQUNsQixLQUFLLE1BQU14SCxPQUFPSixLQUFNO2dCQUNwQixJQUFJaUksS0FBS0MsTUFBTSxLQUFLLElBQUksQ0FBQzVELGlCQUFpQixFQUFFO29CQUN4Q3NELFFBQVEzRixJQUFJLENBQUM3QjtvQkFDYixJQUFJLENBQUN5SCxnQkFBZ0IsQ0FBQ00sR0FBRyxDQUFDL0gsSUFBSTJILEVBQUU7Z0JBQ3BDO1lBQ0o7WUFDQSxPQUFPSDtRQUNYO0lBQ0o7SUFDQSxNQUFNUSxzQkFBc0I7UUFDeEIsTUFBTyxJQUFJLENBQUNDLGNBQWMsQ0FBQzlFLElBQUksSUFBSSxFQUFHO1lBQ2xDLE1BQU0sQ0FBQytFLE9BQU9DLEtBQUssR0FBRyxJQUFJLENBQUNGLGNBQWMsQ0FBQzNFLEdBQUcsQ0FBQyxJQUFJLENBQUN3QiwwQkFBMEI7WUFDN0UsSUFBSSxDQUFDb0QsTUFBTTdFLE1BQU0sRUFBRTtnQkFDZjhFO2dCQUNBO1lBQ0o7WUFDQSxJQUFJO2dCQUNBLE1BQU0sSUFBSSxDQUFDQyxlQUFlLENBQUM7b0JBQ3ZCQyxZQUFZSCxNQUNQSSxNQUFNLENBQUMsQ0FBQzFHLE9BQVNBLEtBQUsyRyxNQUFNLEtBQUssVUFDakN4SSxHQUFHLENBQUMsQ0FBQzZCLE9BQVNBLEtBQUtBLElBQUk7b0JBQzVCNEcsWUFBWU4sTUFDUEksTUFBTSxDQUFDLENBQUMxRyxPQUFTQSxLQUFLMkcsTUFBTSxLQUFLLFVBQ2pDeEksR0FBRyxDQUFDLENBQUM2QixPQUFTQSxLQUFLQSxJQUFJO2dCQUNoQztZQUNKLFNBQ1E7Z0JBQ0p1RztZQUNKO1FBQ0o7SUFDSjtJQUNBLE1BQU1NLG9CQUFvQjdHLElBQUksRUFBRThHLHVCQUF1QixFQUFFO1FBQ3JELE1BQU1DLGFBQWEsSUFBSSxDQUFDQyxnQkFBZ0I7UUFDeENDLGFBQWEsSUFBSSxDQUFDRCxnQkFBZ0I7UUFDbEMsSUFBSSxDQUFDQSxnQkFBZ0IsR0FBR3JJO1FBQ3hCLE1BQU11SSxjQUFjLElBQUksQ0FBQ2IsY0FBYyxDQUFDcEcsSUFBSSxDQUFDRDtRQUM3QyxJQUFJOEcsMkJBQ0EsSUFBSSxDQUFDVCxjQUFjLENBQUM5RSxJQUFJLEdBQUcsSUFBSSxDQUFDMkIsMEJBQTBCLEVBQUU7WUFDNUQsTUFBTSxJQUFJLENBQUNrRCxtQkFBbUI7UUFDbEM7UUFDQSxJQUFJLElBQUksQ0FBQ0MsY0FBYyxDQUFDOUUsSUFBSSxHQUFHLEdBQUc7WUFDOUIsSUFBSSxDQUFDeUYsZ0JBQWdCLEdBQUdsRyxXQUFXO2dCQUMvQixJQUFJLENBQUNrRyxnQkFBZ0IsR0FBR3JJO2dCQUN4QiwrREFBK0Q7Z0JBQy9ELHlDQUF5QztnQkFDekMsS0FBSyxJQUFJLENBQUN5SCxtQkFBbUIsR0FBR2UsS0FBSyxDQUFDQyxRQUFRQyxLQUFLO1lBQ3ZELEdBQUdOLGFBQ0csSUFBSSxDQUFDTywyQkFBMkIsR0FDaEMsSUFBSSxDQUFDQyx1QkFBdUI7UUFDdEM7UUFDQSxPQUFPTDtJQUNYO0lBQ0EsTUFBTU0saUJBQWlCO1FBQ25CLE1BQU1sSSxXQUFXLE1BQU00RSxNQUFNLENBQUMsRUFBRSxJQUFJLENBQUMzQixNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDaEQ0QixRQUFRO1lBQ1J6RCxTQUFTO2dCQUFFK0csUUFBUTtZQUFtQjtZQUN0Q3JELFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO1FBQy9DO1FBQ0EsSUFBSSxDQUFDcEQsU0FBU0ksRUFBRSxFQUFFO1lBQ2Qsc0RBQXNEO1lBQ3RELHFEQUFxRDtZQUNyRCxNQUFNSixTQUFTRyxJQUFJO1lBQ25CLE1BQU0sSUFBSVgsTUFBTTtRQUNwQjtRQUNBLE9BQU9RLFNBQVNrRixJQUFJO0lBQ3hCO0lBQ0EsTUFBTWtELDJCQUEyQjtRQUM3QixJQUFJO1lBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUNILGNBQWM7UUFDL0MsRUFDQSxPQUFPSSxHQUFHO1lBQ04sT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNYO0lBQ0EsTUFBTUMsVUFBVXpKLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDc0gsa0JBQWtCLENBQUM7WUFBQ3RIO1NBQUksRUFBRXFELE1BQU0sRUFBRTtZQUN4QztRQUNKO1FBQ0EsTUFBTWYsVUFBVTtZQUFFLEdBQUcsSUFBSSxDQUFDQSxPQUFPO1lBQUUsZ0JBQWdCO1FBQW1CO1FBQ3RFLE1BQU1vSCxlQUFlMUosSUFBSTJKLFlBQVk7UUFDckMsT0FBTzNKLElBQUkySixZQUFZO1FBQ3ZCLE1BQU1DLFlBQVksSUFBSSxDQUFDdEUsOEJBQThCLENBQUM7WUFDbERvRTtZQUNBLEdBQUcxSixHQUFHO1lBQ042SixZQUFZN0osSUFBSTZKLFVBQVUsSUFBSUMsS0FBS0MsR0FBRztRQUMxQztRQUNBLElBQUksSUFBSSxDQUFDbEYsZ0JBQWdCLElBQ3JCK0UsVUFBVUksUUFBUSxLQUFLekosYUFDdkJxSixVQUFVSyxZQUFZLEtBQUsxSixXQUFXO1lBQ3RDLEtBQUssSUFBSSxDQUFDa0ksbUJBQW1CLENBQUM7Z0JBQzFCRixRQUFRO2dCQUNSM0csTUFBTWdJO1lBQ1YsR0FBR2IsS0FBSyxDQUFDQyxRQUFRQyxLQUFLO1lBQ3RCO1FBQ0o7UUFDQSxNQUFNaUIsd0JBQXdCLE1BQU12Syw4QkFBOEI7WUFDOURpSztTQUNIO1FBQ0QsTUFBTTFJLFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzNCLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNsRTRCLFFBQVE7WUFDUnpEO1lBQ0FsQixNQUFNNEYsS0FBS0MsU0FBUyxDQUFDaUQscUJBQXFCLENBQUMsRUFBRTtZQUM3Q2xFLFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO1FBQy9DO1FBQ0EsTUFBTXJELGVBQWVDLFVBQVU7SUFDbkM7SUFDQTs7O0tBR0MsR0FDRCxNQUFNa0gsZ0JBQWdCLEVBQUVDLFVBQVUsRUFBRUcsVUFBVSxFQUFHLEVBQUU7UUFDL0MsSUFBSUgsZUFBZTlILGFBQWFpSSxlQUFlakksV0FBVztZQUN0RDtRQUNKO1FBQ0EsSUFBSTRKLHVCQUF1QjlCLFlBQVl0SSxJQUFJLENBQUNxSyxTQUFXLElBQUksQ0FBQzlFLDhCQUE4QixDQUFDOEUsWUFBWSxFQUFFO1FBQ3pHLElBQUlDLHVCQUF1QjdCLFlBQVl6SSxJQUFJLENBQUN1SyxTQUFXLElBQUksQ0FBQ2hGLDhCQUE4QixDQUFDZ0YsWUFBWSxFQUFFO1FBQ3pHLElBQUlILHFCQUFxQjlHLE1BQU0sR0FBRyxLQUFLZ0gscUJBQXFCaEgsTUFBTSxHQUFHLEdBQUc7WUFDcEUsTUFBTWtILGFBQWFKLHFCQUFxQkssTUFBTSxDQUFDLENBQUNDLFFBQVF6SztnQkFDcEQsSUFBSSxDQUFDQSxJQUFJMkgsRUFBRSxFQUFFO29CQUNULE9BQU84QztnQkFDWDtnQkFDQUEsTUFBTSxDQUFDekssSUFBSTJILEVBQUUsQ0FBQyxHQUFHM0g7Z0JBQ2pCLE9BQU95SztZQUNYLEdBQUcsQ0FBQztZQUNKLE1BQU1DLG9CQUFvQixFQUFFO1lBQzVCLEtBQUssTUFBTUMsZUFBZU4scUJBQXNCO2dCQUM1QyxJQUFJTSxZQUFZaEQsRUFBRSxLQUFLcEgsYUFBYWdLLFVBQVUsQ0FBQ0ksWUFBWWhELEVBQUUsQ0FBQyxFQUFFO29CQUM1RDRDLFVBQVUsQ0FBQ0ksWUFBWWhELEVBQUUsQ0FBQyxHQUFHO3dCQUN6QixHQUFHNEMsVUFBVSxDQUFDSSxZQUFZaEQsRUFBRSxDQUFDO3dCQUM3QixHQUFHZ0QsV0FBVztvQkFDbEI7Z0JBQ0osT0FDSztvQkFDREQsa0JBQWtCN0ksSUFBSSxDQUFDOEk7Z0JBQzNCO1lBQ0o7WUFDQVIsdUJBQXVCdEgsT0FBTytILE1BQU0sQ0FBQ0w7WUFDckNGLHVCQUF1Qks7UUFDM0I7UUFDQSxNQUFNRyxXQUFXO1lBQ2JDLE1BQU0sSUFBSSxDQUFDeEQsa0JBQWtCLENBQUM2QztZQUM5QjVDLE9BQU8sSUFBSSxDQUFDRCxrQkFBa0IsQ0FBQytDLHNCQUFzQjtRQUN6RDtRQUNBLElBQUksQ0FBQ1EsU0FBU0MsSUFBSSxDQUFDekgsTUFBTSxJQUFJLENBQUN3SCxTQUFTdEQsS0FBSyxDQUFDbEUsTUFBTSxFQUFFO1lBQ2pEO1FBQ0o7UUFDQThHLHVCQUF1QixNQUFNeEssOEJBQThCd0s7UUFDM0QsSUFBSSxJQUFJLENBQUNZLHNCQUFzQixLQUFLeEssV0FBVztZQUMzQyxJQUFJLENBQUN3SyxzQkFBc0IsR0FBRyxNQUFNLElBQUksQ0FBQ3pCLHdCQUF3QjtRQUNyRTtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUN5QixzQkFBc0IsRUFBRTtZQUM5QixJQUFJLENBQUNsRyxnQkFBZ0IsR0FBRztZQUN4QixLQUFLLE1BQU1tRyx1QkFBdUJILFNBQVNDLElBQUksQ0FBRTtnQkFDN0MsTUFBTSxJQUFJLENBQUNyQixTQUFTLENBQUN1QjtZQUN6QjtZQUNBLEtBQUssTUFBTUMsdUJBQXVCSixTQUFTdEQsS0FBSyxDQUFFO2dCQUM5QyxJQUFJMEQsb0JBQW9CdEQsRUFBRSxLQUFLcEgsV0FBVztvQkFDdEMsTUFBTSxJQUFJLENBQUMySyxTQUFTLENBQUNELG9CQUFvQnRELEVBQUUsRUFBRXNEO2dCQUNqRDtZQUNKO1lBQ0E7UUFDSjtRQUNBLE1BQU1FLGlCQUFpQixJQUFJLENBQUM1QixVQUFVLEVBQUU2QixxQkFBcUJDLG9CQUN6RHpIO1FBQ0osTUFBTTBILGNBQWM7WUFDaEJSLE1BQU0sRUFBRTtZQUNSdkQsT0FBTyxFQUFFO1FBQ2I7UUFDQSxJQUFJZ0Usd0JBQXdCO1FBQzVCLEtBQUssTUFBTUMsS0FBSztZQUFDO1lBQVE7U0FBUSxDQUFFO1lBQy9CLE1BQU1DLE1BQU1EO1lBQ1osTUFBTUUsYUFBYWIsUUFBUSxDQUFDWSxJQUFJLENBQUNFLE9BQU87WUFDeEMsSUFBSUMsWUFBWUYsV0FBV3BJLEdBQUc7WUFDOUIsTUFBT3NJLGNBQWNyTCxVQUFXO2dCQUM1QixNQUFNc0wsdUJBQXVCN0UsS0FBS0MsU0FBUyxDQUFDMkU7Z0JBQzVDLElBQUlMLHdCQUF3QixLQUN4QkEsd0JBQXdCTSxxQkFBcUJ4SSxNQUFNLEdBQUc4SCxnQkFBZ0I7b0JBQ3RFLE1BQU0sSUFBSSxDQUFDVyxvQkFBb0IsQ0FBQzlFLEtBQUtDLFNBQVMsQ0FBQ3FFO29CQUMvQ0Msd0JBQXdCO29CQUN4QkQsWUFBWVIsSUFBSSxHQUFHLEVBQUU7b0JBQ3JCUSxZQUFZL0QsS0FBSyxHQUFHLEVBQUU7Z0JBQzFCO2dCQUNBZ0UseUJBQXlCTSxxQkFBcUJ4SSxNQUFNO2dCQUNwRGlJLFdBQVcsQ0FBQ0csSUFBSSxDQUFDNUosSUFBSSxDQUFDK0o7Z0JBQ3RCQSxZQUFZRixXQUFXcEksR0FBRztZQUM5QjtRQUNKO1FBQ0EsSUFBSWdJLFlBQVlSLElBQUksQ0FBQ3pILE1BQU0sR0FBRyxLQUFLaUksWUFBWS9ELEtBQUssQ0FBQ2xFLE1BQU0sR0FBRyxHQUFHO1lBQzdELE1BQU0sSUFBSSxDQUFDeUksb0JBQW9CLENBQUM5RSxLQUFLQyxTQUFTLENBQUNxRTtRQUNuRDtJQUNKO0lBQ0EsTUFBTVEscUJBQXFCMUssSUFBSSxFQUFFO1FBQzdCLE1BQU1rQixVQUFVO1lBQ1osR0FBRyxJQUFJLENBQUNBLE9BQU87WUFDZixnQkFBZ0I7WUFDaEIrRyxRQUFRO1FBQ1o7UUFDQSxNQUFNbkksV0FBVyxNQUFNLElBQUksQ0FBQ3VELGlCQUFpQixDQUFDb0IsSUFBSSxDQUFDQyxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUMzQixNQUFNLENBQUMsV0FBVyxDQUFDLEVBQUU7WUFDbkY0QixRQUFRO1lBQ1J6RDtZQUNBbEIsTUFBTUE7WUFDTjRFLFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO1FBQy9DO1FBQ0EsTUFBTXJELGVBQWVDLFVBQVU7SUFDbkM7SUFDQSxNQUFNZ0ssVUFBVWEsS0FBSyxFQUFFL0wsR0FBRyxFQUFFO1FBQ3hCaUMsV0FBVzhKO1FBQ1gsSUFBSS9MLElBQUltRixNQUFNLEVBQUU7WUFDWm5GLElBQUltRixNQUFNLEdBQUcsSUFBSSxDQUFDRCxhQUFhLENBQUNsRixJQUFJbUYsTUFBTTtRQUM5QztRQUNBLElBQUluRixJQUFJcUYsT0FBTyxFQUFFO1lBQ2JyRixJQUFJcUYsT0FBTyxHQUFHLElBQUksQ0FBQ0QsY0FBYyxDQUFDcEYsSUFBSXFGLE9BQU87UUFDakQ7UUFDQSx1QkFBdUI7UUFDdkIsTUFBTTJHLE9BQU87WUFBRSxHQUFHaE0sR0FBRztZQUFFMkgsSUFBSW9FO1FBQU07UUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQ3pFLGtCQUFrQixDQUFDO1lBQUMwRTtTQUFLLEVBQUUsTUFBTTNJLE1BQU0sRUFBRTtZQUMvQztRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUN3QixnQkFBZ0IsSUFDckJtSCxLQUFLaEMsUUFBUSxLQUFLekosYUFDbEJ5TCxLQUFLL0IsWUFBWSxLQUFLMUosV0FBVztZQUNqQyxJQUFJUCxJQUFJaU0sUUFBUSxLQUFLMUwsYUFBYXlMLEtBQUtFLGFBQWEsS0FBSzNMLFdBQVc7Z0JBQ2hFLGtGQUFrRjtnQkFDbEYsOEJBQThCO2dCQUM5QixNQUFNLElBQUksQ0FBQ2tJLG1CQUFtQixDQUFDO29CQUFFRixRQUFRO29CQUFVM0csTUFBTW9LO2dCQUFLLEdBQUc7Z0JBQ2pFO1lBQ0osT0FDSztnQkFDRCxLQUFLLElBQUksQ0FBQ3ZELG1CQUFtQixDQUFDO29CQUFFRixRQUFRO29CQUFVM0csTUFBTW9LO2dCQUFLLEdBQUdqRCxLQUFLLENBQUNDLFFBQVFDLEtBQUs7WUFDdkY7WUFDQTtRQUNKO1FBQ0EsTUFBTTNHLFVBQVU7WUFBRSxHQUFHLElBQUksQ0FBQ0EsT0FBTztZQUFFLGdCQUFnQjtRQUFtQjtRQUN0RSxNQUFNcEIsV0FBVyxNQUFNLElBQUksQ0FBQ3FELE1BQU0sQ0FBQ3NCLElBQUksQ0FBQ0MsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDM0IsTUFBTSxDQUFDLE1BQU0sRUFBRTRILE1BQU0sQ0FBQyxFQUFFO1lBQzNFaEcsUUFBUTtZQUNSekQ7WUFDQWxCLE1BQU00RixLQUFLQyxTQUFTLENBQUNqSDtZQUNyQmdHLFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO1FBQy9DO1FBQ0EsTUFBTXJELGVBQWVDLFVBQVU7SUFDbkM7SUFDQSxNQUFNaUwsUUFBUUosS0FBSyxFQUFFLEVBQUVLLGFBQWEsRUFBRSxHQUFHO1FBQUVBLGVBQWU7SUFBTSxDQUFDLEVBQUU7UUFDL0RuSyxXQUFXOEo7UUFDWCxJQUFJL0wsTUFBTSxNQUFNLElBQUksQ0FBQ21HLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRTRGLE1BQU0sQ0FBQztRQUMxQyxJQUFJSyxpQkFBaUJwTSxJQUFJcU0sYUFBYSxFQUFFO1lBQ3BDck0sTUFBTSxNQUFNLElBQUksQ0FBQ3NNLGNBQWMsQ0FBQ3RNO1FBQ3BDO1FBQ0EsT0FBT0E7SUFDWDtJQUNBLE1BQU11TSxVQUFVLEVBQUVSLEtBQUssRUFBRS9MLEdBQUcsRUFBRXdNLFdBQVcsRUFBRyxFQUFFO1FBQzFDLElBQUl4TSxRQUFRTyxXQUFXO1lBQ25CLElBQUlrTTtZQUNKLElBQUl6TSxJQUFJME0sVUFBVSxFQUFFO2dCQUNoQkQsWUFBWXpNLElBQUkwTSxVQUFVO1lBQzlCLE9BQ0ssSUFBSUYsYUFBYUcsYUFBYTtnQkFDL0JGLFlBQVksQ0FBQyxNQUFNLElBQUksQ0FBQ0csV0FBVyxDQUFDO29CQUFFRCxhQUFhSCxhQUFhRztnQkFBWSxFQUFDLEVBQUdoRixFQUFFO1lBQ3RGLE9BQ0ssSUFBSTZFLGFBQWFLLFdBQVc7Z0JBQzdCSixZQUFZRCxhQUFhSztZQUM3QixPQUNLO2dCQUNELE1BQU1DLFVBQVUsTUFBTSxJQUFJLENBQUNGLFdBQVcsQ0FBQztvQkFDbkNELGFBQWFwTixxRUFBc0JBLENBQUMsd0JBQXdCO2dCQUNoRTtnQkFDQWtOLFlBQVlLLFFBQVFuRixFQUFFO1lBQzFCO1lBQ0EsTUFBTW9GLFdBQVcsTUFBTSxJQUFJLENBQUNDLFlBQVk7WUFDeEMsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDakksVUFBVSxHQUFHLEdBQUcsRUFBRWdJLFNBQVMsWUFBWSxFQUFFTixVQUFVLEdBQUcsRUFBRXpNLElBQUkySCxFQUFFLENBQUMsVUFBVSxDQUFDO1FBQzdGLE9BQ0ssSUFBSW9FLFVBQVV4TCxXQUFXO1lBQzFCLE1BQU0wTSxPQUFPLE1BQU0sSUFBSSxDQUFDZCxPQUFPLENBQUNKO1lBQ2hDLElBQUksQ0FBQ2tCLEtBQUtDLFFBQVEsRUFBRTtnQkFDaEIsTUFBTSxJQUFJeE0sTUFBTSxDQUFDLElBQUksRUFBRXFMLE1BQU0sZ0JBQWdCLENBQUM7WUFDbEQ7WUFDQSxNQUFNb0IsVUFBVSxJQUFJLENBQUNwSSxVQUFVO1lBQy9CLE9BQU8sQ0FBQyxFQUFFb0ksUUFBUSxFQUFFRixLQUFLQyxRQUFRLENBQUMsQ0FBQztRQUN2QyxPQUNLO1lBQ0QsTUFBTSxJQUFJeE0sTUFBTTtRQUNwQjtJQUNKO0lBQ0EsTUFBTTRMLGVBQWV0TSxHQUFHLEVBQUU7UUFDdEIsTUFBTW9OLFlBQVksTUFBTTNMLFFBQVEsSUFBSSxDQUFDNEwsUUFBUSxDQUFDO1lBQUUxRixJQUFJM0gsSUFBSXFNLGFBQWE7UUFBQztRQUN0RSxNQUFNaUIsVUFBVSxDQUFDO1FBQ2pCLE1BQU0xTixPQUFPLENBQUM7UUFDZCwrREFBK0Q7UUFDL0R3TixVQUFVRyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDRCxHQUFHdkQsZ0JBQWdCLEVBQUMsRUFBR3lELGFBQWEsQ0FBQ0QsR0FBR3hELGdCQUFnQjtRQUNsRixLQUFLLE1BQU0wRCxZQUFZUCxVQUFXO1lBQzlCLElBQUlPLFNBQVN6QixhQUFhLEtBQUssUUFDM0J5QixTQUFTekIsYUFBYSxLQUFLM0wsV0FBVztnQkFDdEMsTUFBTSxJQUFJRyxNQUFNLENBQUMsVUFBVSxFQUFFaU4sU0FBU2hHLEVBQUUsQ0FBQyxjQUFjLENBQUM7WUFDNUQ7WUFDQSxJQUFJLENBQUVnRyxDQUFBQSxTQUFTekIsYUFBYSxJQUFJb0IsT0FBTSxHQUFJO2dCQUN0Q0EsT0FBTyxDQUFDSyxTQUFTekIsYUFBYSxDQUFDLEdBQUcsRUFBRTtZQUN4QztZQUNBb0IsT0FBTyxDQUFDSyxTQUFTekIsYUFBYSxDQUFDLENBQUNySyxJQUFJLENBQUM4TDtZQUNyQy9OLElBQUksQ0FBQytOLFNBQVNoRyxFQUFFLENBQUMsR0FBR2dHO1FBQ3hCO1FBQ0EzTixJQUFJNE4sVUFBVSxHQUFHTixPQUFPLENBQUN0TixJQUFJMkgsRUFBRSxDQUFDLElBQUksRUFBRTtRQUN0QyxJQUFLLE1BQU1vRSxTQUFTdUIsUUFBUztZQUN6QixJQUFJdkIsVUFBVS9MLElBQUkySCxFQUFFLEVBQUU7Z0JBQ2xCL0gsSUFBSSxDQUFDbU0sTUFBTSxDQUFDNkIsVUFBVSxHQUFHTixPQUFPLENBQUN2QixNQUFNO1lBQzNDO1FBQ0o7UUFDQSxPQUFPL0w7SUFDWDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWdGQyxHQUNELE9BQU9xTixTQUFTUSxLQUFLLEVBQUU7UUFDbkIsTUFBTSxFQUFFaEIsU0FBUyxFQUFFRixXQUFXLEVBQUVtQixXQUFXLEVBQUVDLE9BQU8sRUFBRUMsa0JBQWtCLEVBQUVDLFNBQVMsRUFBRUMsY0FBYyxFQUFFQyxPQUFPLEVBQUVsRixLQUFLLEVBQUV0QixFQUFFLEVBQUV5RyxLQUFLLEVBQUU5RixNQUFNLEVBQUUrRixXQUFXLEVBQUVDLFVBQVUsRUFBRTdILEtBQUssRUFBRyxHQUFHb0g7UUFDNUssSUFBSVUsYUFBYSxFQUFFO1FBQ25CLElBQUkxQixXQUFXO1lBQ1gwQixhQUFhQyxNQUFNQyxPQUFPLENBQUM1QixhQUFhQSxZQUFZO2dCQUFDQTthQUFVO1FBQ25FO1FBQ0EsSUFBSUYsYUFBYTtZQUNiLE1BQU0rQixlQUFlRixNQUFNQyxPQUFPLENBQUM5QixlQUM3QkEsY0FDQTtnQkFBQ0E7YUFBWTtZQUNuQixNQUFNZ0MsY0FBYyxNQUFNbk0sUUFBUW9NLEdBQUcsQ0FBQ0YsYUFBYTNPLEdBQUcsQ0FBQyxDQUFDOE8sT0FBUyxJQUFJLENBQUNqQyxXQUFXLENBQUM7b0JBQUVELGFBQWFrQztnQkFBSyxHQUFHQyxJQUFJLENBQUMsQ0FBQ2hDLFVBQVlBLFFBQVFuRixFQUFFO1lBQ3JJNEcsV0FBVzFNLElBQUksSUFBSThNO1FBQ3ZCO1FBQ0EsTUFBTXZOLE9BQU87WUFDVDJOLFNBQVNSLFdBQVdsTCxNQUFNLEdBQUdrTCxhQUFhO1lBQzFDUyxVQUFVYjtZQUNWYyxtQkFBbUJqQjtZQUNuQkk7WUFDQTlGO1lBQ0E0RyxjQUFjYjtZQUNkYyxhQUFhYjtZQUNiYyxpQkFBaUJsQjtZQUNqQm1CLFlBQVl2QjtZQUNaakUsWUFBWW9FLFlBQVlBLFVBQVVxQixXQUFXLEtBQUs7WUFDbERyRztZQUNBdEI7WUFDQWxCO1lBQ0E4SSxPQUFPeEI7UUFDWDtRQUNBLFdBQVcsTUFBTW5PLFFBQVEsSUFBSSxDQUFDZ0gsdUJBQXVCLENBQUMsZUFBZXhGLE1BQU87WUFDeEUsT0FBT3hCO1FBQ1g7SUFDSjtJQUNBLE1BQU00UCxTQUFTekQsS0FBSyxFQUFFLEVBQUUwRCxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUNwQyxNQUFNekQsT0FBTztZQUNUMEQsUUFBUTNEO1lBQ1I0RCxhQUFhRixXQUFXdFEsNENBQU87UUFDbkM7UUFDQThDLFdBQVc4SjtRQUNYLE1BQU03SyxXQUFXLE1BQU0sSUFBSSxDQUFDcUQsTUFBTSxDQUFDc0IsSUFBSSxDQUFDQyxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUMzQixNQUFNLENBQUMsTUFBTSxFQUFFNEgsTUFBTSxNQUFNLENBQUMsRUFBRTtZQUNqRmhHLFFBQVE7WUFDUnpELFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCbEIsTUFBTTRGLEtBQUtDLFNBQVMsQ0FBQytFO1lBQ3JCaEcsUUFBUUMsWUFBWUMsT0FBTyxDQUFDLElBQUksQ0FBQzVCLFVBQVU7UUFDL0M7UUFDQSxNQUFNM0MsU0FBUyxNQUFNVCxTQUFTa0YsSUFBSTtRQUNsQyxJQUFJekUsV0FBVyxRQUFRLENBQUUsa0JBQWlCQSxNQUFLLEdBQUk7WUFDL0MsTUFBTSxJQUFJakIsTUFBTTtRQUNwQjtRQUNBLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQ3FFLFVBQVUsR0FBRyxRQUFRLEVBQUVwRCxNQUFNLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQztJQUNuRTtJQUNBLE1BQU1rTyxXQUFXOUQsS0FBSyxFQUFFO1FBQ3BCOUosV0FBVzhKO1FBQ1gsTUFBTTdLLFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzNCLE1BQU0sQ0FBQyxNQUFNLEVBQUU0SCxNQUFNLE1BQU0sQ0FBQyxFQUFFO1lBQ2pGaEcsUUFBUTtZQUNSekQsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckIwRCxRQUFRQyxZQUFZQyxPQUFPLENBQUMsSUFBSSxDQUFDNUIsVUFBVTtRQUMvQztRQUNBLE1BQU1yRCxlQUFlQyxVQUFVO0lBQ25DO0lBQ0EsTUFBTTRPLGtCQUFrQi9ELEtBQUssRUFBRTtRQUMzQjlKLFdBQVc4SjtRQUNYLE1BQU03SyxXQUFXLE1BQU0sSUFBSSxDQUFDcUQsTUFBTSxDQUFDc0IsSUFBSSxDQUFDQyxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUMzQixNQUFNLENBQUMsTUFBTSxFQUFFNEgsTUFBTSxNQUFNLENBQUMsRUFBRTtZQUNqRmhHLFFBQVE7WUFDUnpELFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCMEQsUUFBUUMsWUFBWUMsT0FBTyxDQUFDLElBQUksQ0FBQzVCLFVBQVU7UUFDL0M7UUFDQSxNQUFNM0MsU0FBUyxNQUFNVCxTQUFTa0YsSUFBSTtRQUNsQyxJQUFJekUsV0FBVyxRQUFRLENBQUUsa0JBQWlCQSxNQUFLLEdBQUk7WUFDL0MsT0FBT3BCO1FBQ1g7UUFDQSxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUN3RSxVQUFVLEdBQUcsUUFBUSxFQUFFcEQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUM7SUFDbkU7SUFDQSxNQUFNb08sZUFBZUMsVUFBVSxFQUFFLEVBQUVDLE1BQU0sRUFBRyxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQy9DLE1BQU12SyxjQUFjLElBQUlZLGdCQUFnQjtZQUNwQ3FKLGFBQWFLO1FBQ2pCO1FBQ0EsSUFBSUMsV0FBVzFQLFdBQVc7WUFDdEIsS0FBSyxNQUFNd0wsU0FBU2tFLE9BQVE7Z0JBQ3hCdkssWUFBWXdLLE1BQU0sQ0FBQyxNQUFNbkU7WUFDN0I7UUFDSjtRQUNBOUosV0FBVytOO1FBQ1gsTUFBTTlPLFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzNCLE1BQU0sQ0FBQyxRQUFRLEVBQUU2TCxXQUFXLEtBQUssRUFBRXRLLFlBQVksQ0FBQyxFQUFFO1lBQ3JHSyxRQUFRO1lBQ1J6RCxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQjBELFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO1FBQy9DO1FBQ0EsTUFBTTFFLE9BQU8sTUFBTXNCLFNBQVNrRixJQUFJO1FBQ2hDLE9BQU94RztJQUNYO0lBQ0EsTUFBTXVRLHdCQUF3QkMsU0FBUyxFQUFFQyxXQUFXLEVBQUU7UUFDbEQsSUFBSSxDQUFDRCxhQUFhLENBQUNDLGFBQWE7WUFDNUIsTUFBTSxJQUFJM1AsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQzBQLFdBQVc7WUFDWixNQUFNRSxVQUFVLE1BQU0sSUFBSSxDQUFDQyxXQUFXLENBQUM7Z0JBQUVGO1lBQVk7WUFDckRELFlBQVlFLFFBQVEzSSxFQUFFO1FBQzFCO1FBQ0ExRixXQUFXbU87UUFDWCxNQUFNbFAsV0FBVyxNQUFNLElBQUksQ0FBQ3FELE1BQU0sQ0FBQ3NCLElBQUksQ0FBQ0MsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDM0IsTUFBTSxDQUFDLFVBQVUsRUFBRWlNLFVBQVUsTUFBTSxDQUFDLEVBQUU7WUFDekZySyxRQUFRO1lBQ1J6RCxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQjBELFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO1FBQy9DO1FBQ0EsTUFBTWtNLGNBQWMsTUFBTXRQLFNBQVNrRixJQUFJO1FBQ3ZDb0ssWUFBWTVQLEdBQUcsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDbUUsVUFBVSxHQUFHLFFBQVEsRUFBRXlMLFlBQVliLFdBQVcsQ0FBQyxFQUFFLENBQUM7UUFDNUUsT0FBT2E7SUFDWDtJQUNBLE1BQU1DLGFBQWFMLFNBQVMsRUFBRUMsV0FBVyxFQUFFO1FBQ3ZDLElBQUksQ0FBQ0QsYUFBYSxDQUFDQyxhQUFhO1lBQzVCLE1BQU0sSUFBSTNQLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUMwUCxXQUFXO1lBQ1osTUFBTUUsVUFBVSxNQUFNLElBQUksQ0FBQ0MsV0FBVyxDQUFDO2dCQUFFRjtZQUFZO1lBQ3JERCxZQUFZRSxRQUFRM0ksRUFBRTtRQUMxQjtRQUNBLE1BQU1xRSxPQUFPO1lBQ1QwRSxZQUFZTjtRQUNoQjtRQUNBbk8sV0FBV21PO1FBQ1gsTUFBTWxQLFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzNCLE1BQU0sQ0FBQyxVQUFVLEVBQUVpTSxVQUFVLE1BQU0sQ0FBQyxFQUFFO1lBQ3pGckssUUFBUTtZQUNSekQsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJsQixNQUFNNEYsS0FBS0MsU0FBUyxDQUFDK0U7WUFDckJoRyxRQUFRQyxZQUFZQyxPQUFPLENBQUMsSUFBSSxDQUFDNUIsVUFBVTtRQUMvQztRQUNBLE1BQU1rTSxjQUFjLE1BQU10UCxTQUFTa0YsSUFBSTtRQUN2Q29LLFlBQVk1UCxHQUFHLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQ21FLFVBQVUsR0FBRyxRQUFRLEVBQUV5TCxZQUFZYixXQUFXLENBQUMsRUFBRSxDQUFDO1FBQzVFLE9BQU9hO0lBQ1g7SUFDQSxNQUFNRyxlQUFlUCxTQUFTLEVBQUU7UUFDNUJuTyxXQUFXbU87UUFDWCxNQUFNbFAsV0FBVyxNQUFNLElBQUksQ0FBQ3FELE1BQU0sQ0FBQ3NCLElBQUksQ0FBQ0MsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDM0IsTUFBTSxDQUFDLFVBQVUsRUFBRWlNLFVBQVUsTUFBTSxDQUFDLEVBQUU7WUFDekZySyxRQUFRO1lBQ1J6RCxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQjBELFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO1FBQy9DO1FBQ0EsTUFBTXJELGVBQWVDLFVBQVU7SUFDbkM7SUFDQSxNQUFNMFAsa0JBQWtCWixVQUFVLEVBQUU7UUFDaEMvTixXQUFXK047UUFDWCxNQUFNOU8sV0FBVyxNQUFNLElBQUksQ0FBQ3FELE1BQU0sQ0FBQ3NCLElBQUksQ0FBQ0MsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDM0IsTUFBTSxDQUFDLFFBQVEsRUFBRTZMLFdBQVcsU0FBUyxDQUFDLEVBQUU7WUFDM0ZqSyxRQUFRO1lBQ1J6RCxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQjBELFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO1FBQy9DO1FBQ0EsTUFBTWdNLFVBQVUsTUFBTXBQLFNBQVNrRixJQUFJO1FBQ25DLE9BQU9rSztJQUNYO0lBQ0EsTUFBTU8sY0FBYyxFQUFFbEUsV0FBVyxFQUFFbUUsY0FBYyxJQUFJLEVBQUU1USxXQUFXLElBQUksRUFBRTZRLFNBQVMsS0FBSyxFQUFFQyxlQUFlLElBQUksRUFBRUMscUJBQXFCLElBQUksRUFBRyxFQUFFO1FBQ3ZJLE1BQU1DLFVBQVVILFNBQVMsQ0FBQyxZQUFZLENBQUMsR0FBRztRQUMxQyxNQUFNSSxXQUFXLENBQUMsRUFBRSxJQUFJLENBQUNoTixNQUFNLENBQUMsU0FBUyxFQUFFK00sUUFBUSxDQUFDO1FBQ3BELE1BQU1qUixRQUFRK1EsZ0JBQWdCLENBQUM7UUFDL0IsSUFBSTlRLFVBQVU7WUFDVkQsS0FBSyxDQUFDLFdBQVcsR0FBR0M7UUFDeEI7UUFDQSxNQUFNa0IsT0FBTztZQUNUeU4sTUFBTWxDO1lBQ04xTTtZQUNBNlE7UUFDSjtRQUNBLElBQUlHLHVCQUF1QixNQUFNO1lBQzdCN1AsSUFBSSxDQUFDLHVCQUF1QixHQUFHNlA7UUFDbkM7UUFDQSxNQUFNL1AsV0FBVyxNQUFNLElBQUksQ0FBQ3FELE1BQU0sQ0FBQ3NCLElBQUksQ0FBQ0MsT0FBT3FMLFVBQVU7WUFDckRwTCxRQUFRO1lBQ1J6RCxTQUFTO2dCQUFFLEdBQUcsSUFBSSxDQUFDQSxPQUFPO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUMvRGxCLE1BQU00RixLQUFLQyxTQUFTLENBQUM3RjtZQUNyQjRFLFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO1FBQy9DO1FBQ0EsTUFBTTNDLFNBQVMsTUFBTVQsU0FBU2tGLElBQUk7UUFDbEMsSUFBSSxDQUFDbEYsU0FBU0ksRUFBRSxFQUFFO1lBQ2QsTUFBTSxJQUFJWixNQUFNLENBQUMseUJBQXlCLEVBQUVpTSxZQUFZLEVBQUUsRUFBRXpMLFNBQVNLLE1BQU0sQ0FBQyxDQUFDLEVBQUVMLFNBQVNNLFVBQVUsQ0FBQyxDQUFDO1FBQ3hHO1FBQ0EsT0FBT0c7SUFDWDtJQUNBLE1BQU15UCxjQUFjdkUsU0FBUyxFQUFFLEVBQUVnQyxPQUFPLElBQUksRUFBRWlDLGNBQWMsSUFBSSxFQUFFNVEsV0FBVyxJQUFJLEVBQUU4USxlQUFlLElBQUksRUFBRUssVUFBVSxJQUFJLEVBQUcsRUFBRTtRQUN2SCxNQUFNRixXQUFXLENBQUMsRUFBRSxJQUFJLENBQUNoTixNQUFNLENBQUMsVUFBVSxFQUFFMEksVUFBVSxDQUFDO1FBQ3ZELElBQUk1TSxRQUFRK1E7UUFDWixJQUFJOVEsVUFBVTtZQUNWRCxRQUFRO2dCQUFFLEdBQUlBLFNBQVMsQ0FBQyxDQUFDO2dCQUFHQztZQUFTO1FBQ3pDO1FBQ0EsTUFBTWtCLE9BQU87WUFDVHlOO1lBQ0E1TztZQUNBNlE7WUFDQTdFLFVBQVVvRixVQUFVLElBQUl2SCxLQUFLdUgsU0FBUy9CLFdBQVcsS0FBSztRQUMxRDtRQUNBLE1BQU1wTyxXQUFXLE1BQU0sSUFBSSxDQUFDcUQsTUFBTSxDQUFDc0IsSUFBSSxDQUFDQyxPQUFPcUwsVUFBVTtZQUNyRHBMLFFBQVE7WUFDUnpELFNBQVM7Z0JBQUUsR0FBRyxJQUFJLENBQUNBLE9BQU87Z0JBQUUsZ0JBQWdCO1lBQW1CO1lBQy9EbEIsTUFBTTRGLEtBQUtDLFNBQVMsQ0FBQzdGO1lBQ3JCNEUsUUFBUUMsWUFBWUMsT0FBTyxDQUFDLElBQUksQ0FBQzVCLFVBQVU7UUFDL0M7UUFDQSxNQUFNM0MsU0FBUyxNQUFNVCxTQUFTa0YsSUFBSTtRQUNsQyxJQUFJLENBQUNsRixTQUFTSSxFQUFFLEVBQUU7WUFDZCxNQUFNLElBQUlaLE1BQU0sQ0FBQyx5QkFBeUIsRUFBRW1NLFVBQVUsRUFBRSxFQUFFM0wsU0FBU0ssTUFBTSxDQUFDLENBQUMsRUFBRUwsU0FBU00sVUFBVSxDQUFDLENBQUM7UUFDdEc7UUFDQSxPQUFPRztJQUNYO0lBQ0EsTUFBTTJQLFdBQVcsRUFBRXpFLFNBQVMsRUFBRUYsV0FBVyxFQUFHLEVBQUU7UUFDMUMsMkJBQTJCO1FBQzNCLElBQUlsSCxPQUFPO1FBQ1gsTUFBTWdGLFNBQVMsSUFBSW5FO1FBQ25CLElBQUl1RyxjQUFjdE0sYUFBYW9NLGdCQUFnQnBNLFdBQVc7WUFDdEQsTUFBTSxJQUFJRyxNQUFNO1FBQ3BCLE9BQ0ssSUFBSW1NLGNBQWN0TSxXQUFXO1lBQzlCMEIsV0FBVzRLO1lBQ1hwSCxRQUFRLENBQUMsQ0FBQyxFQUFFb0gsVUFBVSxDQUFDO1FBQzNCLE9BQ0ssSUFBSUYsZ0JBQWdCcE0sV0FBVztZQUNoQ2tLLE9BQU95RixNQUFNLENBQUMsUUFBUXZEO1FBQzFCLE9BQ0s7WUFDRCxNQUFNLElBQUlqTSxNQUFNO1FBQ3BCO1FBQ0EsTUFBTVEsV0FBVyxNQUFNLElBQUksQ0FBQ3FELE1BQU0sQ0FBQ3NCLElBQUksQ0FBQ0MsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDM0IsTUFBTSxDQUFDLEVBQUVzQixLQUFLLENBQUMsRUFBRWdGLE9BQU8sQ0FBQyxFQUFFO1lBQzlFMUUsUUFBUTtZQUNSekQsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckIwRCxRQUFRQyxZQUFZQyxPQUFPLENBQUMsSUFBSSxDQUFDNUIsVUFBVTtRQUMvQztRQUNBLHNEQUFzRDtRQUN0RCxxREFBcUQ7UUFDckQsSUFBSTtZQUNBLE1BQU0zQyxTQUFTLE1BQU1ULFNBQVNrRixJQUFJO1lBQ2xDLElBQUksQ0FBQ2xGLFNBQVNJLEVBQUUsRUFBRTtnQkFDZCxPQUFPO1lBQ1g7WUFDQSw2RUFBNkU7WUFDN0UsSUFBSWtOLE1BQU1DLE9BQU8sQ0FBQzlNLFNBQVM7Z0JBQ3ZCLE9BQU9BLE9BQU8wQixNQUFNLEdBQUc7WUFDM0I7WUFDQSxxQkFBcUI7WUFDckIsT0FBTztRQUNYLEVBQ0EsT0FBT21HLEdBQUc7WUFDTixPQUFPO1FBQ1g7SUFDSjtJQUNBLE1BQU1vRCxZQUFZLEVBQUVDLFNBQVMsRUFBRUYsV0FBVyxFQUFFNEUsWUFBWSxFQUFHLEVBQUU7UUFDekQsSUFBSTlMLE9BQU87UUFDWCxNQUFNZ0YsU0FBUyxJQUFJbkU7UUFDbkIsSUFBSXVHLGNBQWN0TSxhQUFhb00sZ0JBQWdCcE0sV0FBVztZQUN0RCxNQUFNLElBQUlHLE1BQU07UUFDcEIsT0FDSyxJQUFJbU0sY0FBY3RNLFdBQVc7WUFDOUIwQixXQUFXNEs7WUFDWHBILFFBQVEsQ0FBQyxDQUFDLEVBQUVvSCxVQUFVLENBQUM7UUFDM0IsT0FDSyxJQUFJRixnQkFBZ0JwTSxXQUFXO1lBQ2hDa0ssT0FBT3lGLE1BQU0sQ0FBQyxRQUFRdkQ7UUFDMUIsT0FDSztZQUNELE1BQU0sSUFBSWpNLE1BQU07UUFDcEI7UUFDQSxJQUFJNlEsaUJBQWlCaFIsV0FBVztZQUM1QmtLLE9BQU95RixNQUFNLENBQUMsaUJBQWlCcUIsYUFBYTNMLFFBQVE7UUFDeEQ7UUFDQSxNQUFNMUUsV0FBVyxNQUFNLElBQUksQ0FBQ2lGLElBQUksQ0FBQ1YsTUFBTWdGO1FBQ3ZDLElBQUk5STtRQUNKLElBQUk2TSxNQUFNQyxPQUFPLENBQUN2TixXQUFXO1lBQ3pCLElBQUlBLFNBQVNtQyxNQUFNLEtBQUssR0FBRztnQkFDdkIsTUFBTSxJQUFJM0MsTUFBTSxDQUFDLFdBQVcsRUFBRW1NLFVBQVUsT0FBTyxFQUFFRixZQUFZLFdBQVcsQ0FBQztZQUM3RTtZQUNBaEwsU0FBU1QsUUFBUSxDQUFDLEVBQUU7UUFDeEIsT0FDSztZQUNEUyxTQUFTVDtRQUNiO1FBQ0EsT0FBT1M7SUFDWDtJQUNBLE1BQU1xTCxlQUFlO1FBQ2pCLElBQUksSUFBSSxDQUFDd0UsU0FBUyxLQUFLLE1BQU07WUFDekIsT0FBTyxJQUFJLENBQUNBLFNBQVM7UUFDekI7UUFDQSxNQUFNOUwsY0FBYyxJQUFJWSxnQkFBZ0I7WUFBRUcsT0FBTztRQUFJO1FBQ3JELFdBQVcsTUFBTWdMLFlBQVksSUFBSSxDQUFDcEwsYUFBYSxDQUFDLGFBQWFYLGFBQWM7WUFDdkUsSUFBSSxDQUFDOEwsU0FBUyxHQUFHQyxRQUFRLENBQUMsRUFBRSxDQUFDQyxTQUFTO1lBQ3RDLE9BQU9ELFFBQVEsQ0FBQyxFQUFFLENBQUNDLFNBQVM7UUFDaEM7UUFDQSxNQUFNLElBQUloUixNQUFNO0lBQ3BCO0lBQ0EsT0FBT2lSLGFBQWEsRUFBRXBELFVBQVUsRUFBRU0sSUFBSSxFQUFFK0MsWUFBWSxFQUFFWCxrQkFBa0IsRUFBRVksb0JBQW9CLEVBQUVDLGFBQWEsRUFBRyxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ25ILE1BQU1ySCxTQUFTLElBQUluRTtRQUNuQixJQUFJaUksZUFBZWhPLFdBQVc7WUFDMUIsS0FBSyxNQUFNc00sYUFBYTBCLFdBQVk7Z0JBQ2hDOUQsT0FBT3lGLE1BQU0sQ0FBQyxNQUFNckQ7WUFDeEI7UUFDSjtRQUNBLElBQUlnQyxTQUFTdE8sV0FBVztZQUNwQmtLLE9BQU95RixNQUFNLENBQUMsUUFBUXJCO1FBQzFCO1FBQ0EsSUFBSStDLGlCQUFpQnJSLFdBQVc7WUFDNUJrSyxPQUFPeUYsTUFBTSxDQUFDLGlCQUFpQjBCO1FBQ25DO1FBQ0EsSUFBSVgsdUJBQXVCMVEsV0FBVztZQUNsQ2tLLE9BQU95RixNQUFNLENBQUMscUJBQXFCZTtRQUN2QyxPQUNLLElBQUlZLHlCQUF5QnRSLFdBQVc7WUFDekMsTUFBTStQLFVBQVUsTUFBTSxJQUFJLENBQUNDLFdBQVcsQ0FBQztnQkFDbkNGLGFBQWF3QjtZQUNqQjtZQUNBcEgsT0FBT3lGLE1BQU0sQ0FBQyxxQkFBcUJJLFFBQVEzSSxFQUFFO1FBQ2pEO1FBQ0EsSUFBSW1LLGtCQUFrQnZSLFdBQVc7WUFDN0JrSyxPQUFPeUYsTUFBTSxDQUFDLGtCQUFrQjRCLGNBQWNsTSxRQUFRO1FBQzFEO1FBQ0EsV0FBVyxNQUFNNkwsWUFBWSxJQUFJLENBQUNwTCxhQUFhLENBQUMsYUFBYW9FLFFBQVM7WUFDbEUsT0FBT2dIO1FBQ1g7SUFDSjtJQUNBLE1BQU1NLGNBQWMsRUFBRWxGLFNBQVMsRUFBRUYsV0FBVyxFQUFHLEVBQUU7UUFDN0MsSUFBSXFGO1FBQ0osSUFBSW5GLGNBQWN0TSxhQUFhb00sZ0JBQWdCcE0sV0FBVztZQUN0RCxNQUFNLElBQUlHLE1BQU07UUFDcEIsT0FDSyxJQUFJbU0sY0FBY3RNLGFBQWFvTSxnQkFBZ0JwTSxXQUFXO1lBQzNELE1BQU0sSUFBSUcsTUFBTTtRQUNwQixPQUNLLElBQUltTSxjQUFjdE0sV0FBVztZQUM5QnlSLGFBQWEsQ0FBQyxNQUFNLElBQUksQ0FBQ3BGLFdBQVcsQ0FBQztnQkFBRUQ7WUFBWSxFQUFDLEVBQUdoRixFQUFFO1FBQzdELE9BQ0s7WUFDRHFLLGFBQWFuRjtRQUNqQjtRQUNBNUssV0FBVytQO1FBQ1gsTUFBTTlRLFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzNCLE1BQU0sQ0FBQyxVQUFVLEVBQUU2TixXQUFXLENBQUMsRUFBRTtZQUNwRmpNLFFBQVE7WUFDUnpELFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCMEQsUUFBUUMsWUFBWUMsT0FBTyxDQUFDLElBQUksQ0FBQzVCLFVBQVU7UUFDL0M7UUFDQSxNQUFNckQsZUFBZUMsVUFBVSxDQUFDLGVBQWUsRUFBRThRLFdBQVcsRUFBRSxFQUFFckYsWUFBWSxDQUFDLENBQUM7SUFDbEY7SUFDQSxNQUFNc0YsVUFBVSxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxVQUFVLEVBQUV2QixXQUFXLEVBQUV3QixRQUFRLEVBQUV6RCxJQUFJLEVBQUcsRUFBRTtRQUN4RixNQUFNak8sTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDdUQsTUFBTSxDQUFDLGdCQUFnQixDQUFDO1FBQzVDLE1BQU1vTyxXQUFXLElBQUlDO1FBQ3JCRCxTQUFTckMsTUFBTSxDQUFDLFFBQVFnQyxTQUFTQztRQUNqQ0MsVUFBVXpPLE9BQU8sQ0FBQyxDQUFDOEg7WUFDZjhHLFNBQVNyQyxNQUFNLENBQUMsY0FBY3pFO1FBQ2xDO1FBQ0E0RyxXQUFXMU8sT0FBTyxDQUFDLENBQUM4SDtZQUNoQjhHLFNBQVNyQyxNQUFNLENBQUMsZUFBZXpFO1FBQ25DO1FBQ0EsSUFBSXFGLGFBQWE7WUFDYnlCLFNBQVNyQyxNQUFNLENBQUMsZUFBZVk7UUFDbkM7UUFDQSxJQUFJd0IsVUFBVTtZQUNWQyxTQUFTckMsTUFBTSxDQUFDLGFBQWFvQztRQUNqQztRQUNBLElBQUl6RCxNQUFNO1lBQ04wRCxTQUFTckMsTUFBTSxDQUFDLFFBQVFyQjtRQUM1QjtRQUNBLE1BQU0zTixXQUFXLE1BQU0sSUFBSSxDQUFDcUQsTUFBTSxDQUFDc0IsSUFBSSxDQUFDQyxPQUFPbEYsS0FBSztZQUNoRG1GLFFBQVE7WUFDUnpELFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCbEIsTUFBTW1SO1lBQ052TSxRQUFRQyxZQUFZQyxPQUFPLENBQUMsSUFBSSxDQUFDNUIsVUFBVTtRQUMvQztRQUNBLElBQUksQ0FBQ3BELFNBQVNJLEVBQUUsRUFBRTtZQUNkLE1BQU1LLFNBQVMsTUFBTVQsU0FBU2tGLElBQUk7WUFDbEMsSUFBSXpFLE9BQU84USxNQUFNLElBQUk5USxPQUFPOFEsTUFBTSxDQUFDek4sUUFBUSxDQUFDLG1CQUFtQjtnQkFDM0QsTUFBTSxJQUFJdEUsTUFBTSxDQUFDLFFBQVEsRUFBRXlSLFNBQVMsZUFBZSxDQUFDO1lBQ3hEO1lBQ0EsTUFBTSxJQUFJelIsTUFBTSxDQUFDLHNCQUFzQixFQUFFUSxTQUFTSyxNQUFNLENBQUMsQ0FBQyxFQUFFTCxTQUFTTSxVQUFVLENBQUMsQ0FBQztRQUNyRjtRQUNBLE1BQU1HLFNBQVMsTUFBTVQsU0FBU2tGLElBQUk7UUFDbEMsT0FBT3pFO0lBQ1g7SUFDQSxNQUFNK1EsY0FBYzdELElBQUksRUFBRSxFQUFFaUMsV0FBVyxFQUFFd0IsUUFBUSxFQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDdkQsTUFBTWxSLE9BQU87WUFDVHlOO1lBQ0FpQztRQUNKO1FBQ0EsSUFBSXdCLFVBQVU7WUFDVmxSLEtBQUt1UixTQUFTLEdBQUdMO1FBQ3JCO1FBQ0EsTUFBTXBSLFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzNCLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUN0RTRCLFFBQVE7WUFDUnpELFNBQVM7Z0JBQUUsR0FBRyxJQUFJLENBQUNBLE9BQU87Z0JBQUUsZ0JBQWdCO1lBQW1CO1lBQy9EbEIsTUFBTTRGLEtBQUtDLFNBQVMsQ0FBQzdGO1lBQ3JCNEUsUUFBUUMsWUFBWUMsT0FBTyxDQUFDLElBQUksQ0FBQzVCLFVBQVU7UUFDL0M7UUFDQSxJQUFJLENBQUNwRCxTQUFTSSxFQUFFLEVBQUU7WUFDZCxNQUFNSyxTQUFTLE1BQU1ULFNBQVNrRixJQUFJO1lBQ2xDLElBQUl6RSxPQUFPOFEsTUFBTSxJQUFJOVEsT0FBTzhRLE1BQU0sQ0FBQ3pOLFFBQVEsQ0FBQyxtQkFBbUI7Z0JBQzNELE1BQU0sSUFBSXRFLE1BQU0sQ0FBQyxRQUFRLEVBQUVtTyxLQUFLLGVBQWUsQ0FBQztZQUNwRDtZQUNBLE1BQU0sSUFBSW5PLE1BQU0sQ0FBQyx5QkFBeUIsRUFBRVEsU0FBU0ssTUFBTSxDQUFDLENBQUMsRUFBRUwsU0FBU00sVUFBVSxDQUFDLENBQUM7UUFDeEY7UUFDQSxNQUFNRyxTQUFTLE1BQU1ULFNBQVNrRixJQUFJO1FBQ2xDLE9BQU96RTtJQUNYO0lBQ0EsTUFBTTRPLFlBQVksRUFBRUgsU0FBUyxFQUFFQyxXQUFXLEVBQUcsRUFBRTtRQUMzQyxJQUFJNUssT0FBTztRQUNYLG9CQUFvQjtRQUNwQixNQUFNZ0YsU0FBUyxJQUFJbkUsZ0JBQWdCO1lBQUVHLE9BQU87UUFBSTtRQUNoRCxJQUFJMkosY0FBYzdQLGFBQWE4UCxnQkFBZ0I5UCxXQUFXO1lBQ3RELE1BQU0sSUFBSUcsTUFBTTtRQUNwQixPQUNLLElBQUkwUCxjQUFjN1AsV0FBVztZQUM5QjBCLFdBQVdtTztZQUNYM0ssUUFBUSxDQUFDLENBQUMsRUFBRTJLLFVBQVUsQ0FBQztRQUMzQixPQUNLLElBQUlDLGdCQUFnQjlQLFdBQVc7WUFDaENrSyxPQUFPeUYsTUFBTSxDQUFDLFFBQVFHO1FBQzFCLE9BQ0s7WUFDRCxNQUFNLElBQUkzUCxNQUFNO1FBQ3BCO1FBQ0EsTUFBTVEsV0FBVyxNQUFNLElBQUksQ0FBQ2lGLElBQUksQ0FBQ1YsTUFBTWdGO1FBQ3ZDLElBQUk5STtRQUNKLElBQUk2TSxNQUFNQyxPQUFPLENBQUN2TixXQUFXO1lBQ3pCLElBQUlBLFNBQVNtQyxNQUFNLEtBQUssR0FBRztnQkFDdkIsTUFBTSxJQUFJM0MsTUFBTSxDQUFDLFdBQVcsRUFBRTBQLFVBQVUsT0FBTyxFQUFFQyxZQUFZLFdBQVcsQ0FBQztZQUM3RTtZQUNBMU8sU0FBU1QsUUFBUSxDQUFDLEVBQUU7UUFDeEIsT0FDSztZQUNEUyxTQUFTVDtRQUNiO1FBQ0EsT0FBT1M7SUFDWDtJQUNBLE1BQU1pUixvQkFBb0IsRUFBRXhDLFNBQVMsRUFBRUMsV0FBVyxFQUFFd0MsV0FBVyxFQUFFQyxTQUFTLEVBQUcsRUFBRTtRQUMzRSxJQUFJQyxhQUFhM0M7UUFDakIsSUFBSTJDLGVBQWV4UyxhQUFhOFAsZ0JBQWdCOVAsV0FBVztZQUN2RCxNQUFNLElBQUlHLE1BQU07UUFDcEIsT0FDSyxJQUFJcVMsZUFBZXhTLGFBQWE4UCxnQkFBZ0I5UCxXQUFXO1lBQzVELE1BQU0sSUFBSUcsTUFBTTtRQUNwQixPQUNLLElBQUlxUyxlQUFleFMsV0FBVztZQUMvQixNQUFNK1AsVUFBVSxNQUFNLElBQUksQ0FBQ0MsV0FBVyxDQUFDO2dCQUFFRjtZQUFZO1lBQ3JEMEMsYUFBYXpDLFFBQVEzSSxFQUFFO1FBQzNCO1FBQ0EsTUFBTXFMLFlBQVksSUFBSTFNLGdCQUFnQjtZQUNsQzJNLGNBQWMsT0FBT0osZ0JBQWdCLFdBQy9CQSxjQUNBQSxZQUFZdkQsV0FBVztZQUM3QjRELFlBQVksT0FBT0osY0FBYyxXQUFXQSxZQUFZQSxVQUFVeEQsV0FBVztRQUNqRjtRQUNBLE1BQU1wTyxXQUFXLE1BQU0sSUFBSSxDQUFDaUYsSUFBSSxDQUFDLENBQUMsVUFBVSxFQUFFNE0sV0FBVyxjQUFjLENBQUMsRUFBRUM7UUFDMUUsT0FBTzlSO0lBQ1g7SUFDQSxNQUFNaVMsNEJBQTRCLEVBQUUvQyxTQUFTLEVBQUVDLFdBQVcsRUFBRyxFQUFFO1FBQzNELE1BQU01SyxPQUFPO1FBQ2IsSUFBSTJLLGNBQWM3UCxXQUFXO1FBQ3pCLGFBQWE7UUFDakIsT0FDSyxJQUFJOFAsZ0JBQWdCOVAsV0FBVztZQUNoQzZQLFlBQVksQ0FBQyxNQUFNLElBQUksQ0FBQ0csV0FBVyxDQUFDO2dCQUFFRjtZQUFZLEVBQUMsRUFBRzFJLEVBQUU7UUFDNUQsT0FDSztZQUNELE1BQU0sSUFBSWpILE1BQU07UUFDcEI7UUFDQSxNQUFNUSxXQUFXLE1BQU0sSUFBSSxDQUFDc0UsWUFBWSxDQUFDLENBQUMsRUFBRUMsS0FBSyxDQUFDLEVBQUUySyxVQUFVLFVBQVUsQ0FBQztRQUN6RSxNQUFNZ0QsY0FBYyxNQUFNbFMsU0FBU0csSUFBSTtRQUN2QyxNQUFNaVAsVUFBVThDLFlBQ1hwUixJQUFJLEdBQ0poQixLQUFLLENBQUMsTUFDTmpCLEdBQUcsQ0FBQyxDQUFDc1QsT0FBU3JNLEtBQUtzTSxLQUFLLENBQUNEO1FBQzlCLE9BQU8vQztJQUNYO0lBQ0EsT0FBT2lELGFBQWEsRUFBRTlNLFFBQVEsR0FBRyxFQUFFRixTQUFTLENBQUMsRUFBRWlOLFVBQVUsRUFBRW5ELFdBQVcsRUFBRW9ELG1CQUFtQixFQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDakcsTUFBTWhPLE9BQU87UUFDYixNQUFNZ0YsU0FBUyxJQUFJbkUsZ0JBQWdCO1lBQy9CRyxPQUFPQSxNQUFNYixRQUFRO1lBQ3JCVyxRQUFRQSxPQUFPWCxRQUFRO1FBQzNCO1FBQ0EsSUFBSTROLGVBQWVqVCxXQUFXO1lBQzFCLEtBQUssTUFBTW1ULE9BQU9GLFdBQVk7Z0JBQzFCL0ksT0FBT3lGLE1BQU0sQ0FBQyxNQUFNd0Q7WUFDeEI7UUFDSjtRQUNBLElBQUlyRCxnQkFBZ0I5UCxXQUFXO1lBQzNCa0ssT0FBT3lGLE1BQU0sQ0FBQyxRQUFRRztRQUMxQjtRQUNBLElBQUlvRCx3QkFBd0JsVCxXQUFXO1lBQ25Da0ssT0FBT3lGLE1BQU0sQ0FBQyxpQkFBaUJ1RDtRQUNuQztRQUNBLFdBQVcsTUFBTUUsWUFBWSxJQUFJLENBQUN0TixhQUFhLENBQUNaLE1BQU1nRixRQUFTO1lBQzNELE9BQU9rSjtRQUNYO0lBQ0o7SUFDQSxNQUFNQyxjQUFjLEVBQUV4RCxTQUFTLEVBQUVDLFdBQVcsRUFBRyxFQUFFO1FBQzdDLElBQUk1SyxPQUFPO1FBQ1gsSUFBSXNOLGFBQWEzQztRQUNqQixJQUFJQSxjQUFjN1AsYUFBYThQLGdCQUFnQjlQLFdBQVc7WUFDdEQsTUFBTSxJQUFJRyxNQUFNO1FBQ3BCLE9BQ0ssSUFBSTJQLGdCQUFnQjlQLFdBQVc7WUFDaEMsTUFBTStQLFVBQVUsTUFBTSxJQUFJLENBQUNDLFdBQVcsQ0FBQztnQkFBRUY7WUFBWTtZQUNyRDBDLGFBQWF6QyxRQUFRM0ksRUFBRTtRQUMzQjtRQUNBLElBQUlvTCxlQUFleFMsV0FBVztZQUMxQjBCLFdBQVc4UTtZQUNYdE4sUUFBUSxDQUFDLENBQUMsRUFBRXNOLFdBQVcsQ0FBQztRQUM1QixPQUNLO1lBQ0QsTUFBTSxJQUFJclMsTUFBTTtRQUNwQjtRQUNBLE1BQU1RLFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU8sSUFBSSxDQUFDM0IsTUFBTSxHQUFHc0IsTUFBTTtZQUMvRE0sUUFBUTtZQUNSekQsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckIwRCxRQUFRQyxZQUFZQyxPQUFPLENBQUMsSUFBSSxDQUFDNUIsVUFBVTtRQUMvQztRQUNBLElBQUksQ0FBQ3BELFNBQVNJLEVBQUUsRUFBRTtZQUNkLE1BQU0sSUFBSVosTUFBTSxDQUFDLGlCQUFpQixFQUFFK0UsS0FBSyxFQUFFLEVBQUV2RSxTQUFTSyxNQUFNLENBQUMsQ0FBQyxFQUFFTCxTQUFTTSxVQUFVLENBQUMsQ0FBQztRQUN6RjtRQUNBLE1BQU1OLFNBQVNrRixJQUFJO0lBQ3ZCO0lBQ0EsTUFBTXlOLGNBQWMxTyxNQUFNLEVBQUVFLE9BQU8sRUFBRSxFQUFFK0ssU0FBUyxFQUFFQyxXQUFXLEVBQUV5RCxTQUFTLEVBQUVDLFNBQVMsRUFBRSxFQUFFO1FBQ25GLElBQUloQixhQUFhM0M7UUFDakIsSUFBSTJDLGVBQWV4UyxhQUFhOFAsZ0JBQWdCOVAsV0FBVztZQUN2RCxNQUFNLElBQUlHLE1BQU07UUFDcEIsT0FDSyxJQUFJcVMsZUFBZXhTLGFBQWE4UCxnQkFBZ0I5UCxXQUFXO1lBQzVELE1BQU0sSUFBSUcsTUFBTTtRQUNwQixPQUNLLElBQUlxUyxlQUFleFMsV0FBVztZQUMvQixNQUFNK1AsVUFBVSxNQUFNLElBQUksQ0FBQ0MsV0FBVyxDQUFDO2dCQUFFRjtZQUFZO1lBQ3JEMEMsYUFBYXpDLFFBQVEzSSxFQUFFO1FBQzNCO1FBQ0EsTUFBTXFNLGFBQWFGLGFBQWEsSUFBSWhLO1FBQ3BDLE1BQU1rQyxPQUFPO1lBQ1QwRSxZQUFZcUM7WUFDWjVOO1lBQ0FFO1lBQ0E0TyxZQUFZRCxZQUFZMUU7WUFDeEIzSCxJQUFJb007UUFDUjtRQUNBLE1BQU03UyxXQUFXLE1BQU0sSUFBSSxDQUFDcUQsTUFBTSxDQUFDc0IsSUFBSSxDQUFDQyxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUMzQixNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDdEU0QixRQUFRO1lBQ1J6RCxTQUFTO2dCQUFFLEdBQUcsSUFBSSxDQUFDQSxPQUFPO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUMvRGxCLE1BQU00RixLQUFLQyxTQUFTLENBQUMrRTtZQUNyQmhHLFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO1FBQy9DO1FBQ0EsSUFBSSxDQUFDcEQsU0FBU0ksRUFBRSxFQUFFO1lBQ2QsTUFBTSxJQUFJWixNQUFNLENBQUMsMEJBQTBCLEVBQUVRLFNBQVNLLE1BQU0sQ0FBQyxDQUFDLEVBQUVMLFNBQVNNLFVBQVUsQ0FBQyxDQUFDO1FBQ3pGO1FBQ0EsTUFBTUcsU0FBUyxNQUFNVCxTQUFTa0YsSUFBSTtRQUNsQyxPQUFPekU7SUFDWDtJQUNBLE1BQU11UyxlQUFlckcsS0FBSyxFQUFFO1FBQ3hCLE1BQU0sRUFBRTFJLE1BQU0sRUFBRUUsT0FBTyxFQUFFOE8sWUFBWSxFQUFFQyxVQUFVLEVBQUVoRSxTQUFTLEVBQUVDLFdBQVcsRUFBRyxHQUFHeEM7UUFDL0UsSUFBSWtGLGFBQWEzQztRQUNqQixJQUFJMkMsZUFBZXhTLGFBQWE4UCxnQkFBZ0I5UCxXQUFXO1lBQ3ZELE1BQU0sSUFBSUcsTUFBTTtRQUNwQixPQUNLLElBQUlxUyxlQUFleFMsYUFBYThQLGdCQUFnQjlQLFdBQVc7WUFDNUQsTUFBTSxJQUFJRyxNQUFNO1FBQ3BCLE9BQ0ssSUFBSXFTLGVBQWV4UyxXQUFXO1lBQy9CLE1BQU0rUCxVQUFVLE1BQU0sSUFBSSxDQUFDQyxXQUFXLENBQUM7Z0JBQUVGO1lBQVk7WUFDckQwQyxhQUFhekMsUUFBUTNJLEVBQUU7UUFDM0I7UUFDQSxNQUFNME0sb0JBQW9CbFAsT0FBT3BGLEdBQUcsQ0FBQyxDQUFDdVUsT0FBT0M7WUFDekMsT0FBTztnQkFDSDdELFlBQVlxQztnQkFDWjVOLFFBQVFtUDtnQkFDUmpQLFNBQVNBLFVBQVVBLE9BQU8sQ0FBQ2tQLElBQUksR0FBR2hVO2dCQUNsQ29ILElBQUl5TSxhQUFhQSxVQUFVLENBQUNHLElBQUksR0FBR2hVO2dCQUNuQ2lVLGVBQWVMLGVBQWVBLFlBQVksQ0FBQ0ksSUFBSSxHQUFHaFU7WUFDdEQ7UUFDSjtRQUNBLE1BQU1XLFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzNCLE1BQU0sQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUMzRTRCLFFBQVE7WUFDUnpELFNBQVM7Z0JBQUUsR0FBRyxJQUFJLENBQUNBLE9BQU87Z0JBQUUsZ0JBQWdCO1lBQW1CO1lBQy9EbEIsTUFBTTRGLEtBQUtDLFNBQVMsQ0FBQ29OO1lBQ3JCck8sUUFBUUMsWUFBWUMsT0FBTyxDQUFDLElBQUksQ0FBQzVCLFVBQVU7UUFDL0M7UUFDQSxJQUFJLENBQUNwRCxTQUFTSSxFQUFFLEVBQUU7WUFDZCxNQUFNLElBQUlaLE1BQU0sQ0FBQywyQkFBMkIsRUFBRVEsU0FBU0ssTUFBTSxDQUFDLENBQUMsRUFBRUwsU0FBU00sVUFBVSxDQUFDLENBQUM7UUFDMUY7UUFDQSxNQUFNRyxTQUFTLE1BQU1ULFNBQVNrRixJQUFJO1FBQ2xDLE9BQU96RTtJQUNYO0lBQ0EsTUFBTThTLGlCQUFpQkgsS0FBSyxFQUFFSSxVQUFVLEVBQUVDLE9BQU8sRUFBRTtRQUMvQyxPQUFPLElBQUksQ0FBQ2QsYUFBYSxDQUFDO1lBQUVTO1FBQU0sR0FBRztZQUFFTSxRQUFRRjtRQUFXLEdBQUdDO0lBQ2pFO0lBQ0EsTUFBTUUsa0JBQWtCUCxLQUFLLEVBQUVRLFdBQVcsRUFBRUgsT0FBTyxFQUFFO1FBQ2pELE1BQU1JLGFBQWFULE1BQU12VSxHQUFHLENBQUMsQ0FBQ2lWO1lBQzFCLElBQUkxVixzRUFBa0JBLENBQUMwVixVQUFVO2dCQUM3QixPQUFPM1Ysb0ZBQWdDQSxDQUFDMlY7WUFDNUM7WUFDQSxPQUFPQTtRQUNYO1FBQ0EsTUFBTUMsY0FBYzNWLHNFQUFrQkEsQ0FBQ3dWLGVBQ2pDelYsb0ZBQWdDQSxDQUFDeVYsZUFDakNBO1FBQ04sT0FBTyxJQUFJLENBQUNqQixhQUFhLENBQUM7WUFBRVMsT0FBT1M7UUFBVyxHQUFHO1lBQUVILFFBQVFLO1FBQVksR0FBR047SUFDOUU7SUFDQSxNQUFNTyxZQUFZbkIsU0FBUyxFQUFFO1FBQ3pCOVIsV0FBVzhSO1FBQ1gsTUFBTXRPLE9BQU8sQ0FBQyxVQUFVLEVBQUVzTyxVQUFVLENBQUM7UUFDckMsT0FBTyxNQUFNLElBQUksQ0FBQzVOLElBQUksQ0FBQ1Y7SUFDM0I7SUFDQSxPQUFPMFAsYUFBYSxFQUFFL0UsU0FBUyxFQUFFQyxXQUFXLEVBQUUrRCxVQUFVLEVBQUVnQixJQUFJLEVBQUVDLFlBQVksRUFBRyxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ2xGLElBQUl0QztRQUNKLElBQUkzQyxjQUFjN1AsYUFBYThQLGdCQUFnQjlQLFdBQVc7WUFDdEQsTUFBTSxJQUFJRyxNQUFNO1FBQ3BCLE9BQ0ssSUFBSTBQLGNBQWM3UCxXQUFXO1lBQzlCd1MsYUFBYTNDO1FBQ2pCLE9BQ0ssSUFBSUMsZ0JBQWdCOVAsV0FBVztZQUNoQyxNQUFNK1AsVUFBVSxNQUFNLElBQUksQ0FBQ0MsV0FBVyxDQUFDO2dCQUFFRjtZQUFZO1lBQ3JEMEMsYUFBYXpDLFFBQVEzSSxFQUFFO1FBQzNCLE9BQ0s7WUFDRCxNQUFNLElBQUlqSCxNQUFNO1FBQ3BCO1FBQ0EsTUFBTStKLFNBQVMsSUFBSW5FLGdCQUFnQjtZQUFFZ0ssU0FBU3lDO1FBQVc7UUFDekQsTUFBTXVDLGtCQUFrQkYsT0FDbEIsT0FBT0EsU0FBUyxXQUNaQSxPQUNBQSxNQUFNOUYsZ0JBQ1YvTztRQUNOLElBQUkrVSxpQkFBaUI7WUFDakI3SyxPQUFPeUYsTUFBTSxDQUFDLFNBQVNvRjtRQUMzQjtRQUNBLE1BQU1DLGdCQUFnQkYsZ0JBQWdCO1FBQ3RDNUssT0FBT3lGLE1BQU0sQ0FBQyxrQkFBa0JxRixjQUFjM1AsUUFBUTtRQUN0RCxJQUFJd08sZUFBZTdULFdBQVc7WUFDMUIsS0FBSyxNQUFNbVQsT0FBT1UsV0FBWTtnQkFDMUIzSixPQUFPeUYsTUFBTSxDQUFDLE1BQU13RDtZQUN4QjtRQUNKO1FBQ0EsV0FBVyxNQUFNOEIsWUFBWSxJQUFJLENBQUNuUCxhQUFhLENBQUMsYUFBYW9FLFFBQVM7WUFDbEUsT0FBTytLO1FBQ1g7SUFDSjtJQUNBLE1BQU1DLGNBQWMxQixTQUFTLEVBQUU7UUFDM0I5UixXQUFXOFI7UUFDWCxNQUFNdE8sT0FBTyxDQUFDLFVBQVUsRUFBRXNPLFVBQVUsQ0FBQztRQUNyQyxNQUFNN1MsV0FBVyxNQUFNLElBQUksQ0FBQ3FELE1BQU0sQ0FBQ3NCLElBQUksQ0FBQ0MsT0FBTyxJQUFJLENBQUMzQixNQUFNLEdBQUdzQixNQUFNO1lBQy9ETSxRQUFRO1lBQ1J6RCxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQjBELFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO1FBQy9DO1FBQ0EsSUFBSSxDQUFDcEQsU0FBU0ksRUFBRSxFQUFFO1lBQ2QsTUFBTSxJQUFJWixNQUFNLENBQUMsaUJBQWlCLEVBQUUrRSxLQUFLLEVBQUUsRUFBRXZFLFNBQVNLLE1BQU0sQ0FBQyxDQUFDLEVBQUVMLFNBQVNNLFVBQVUsQ0FBQyxDQUFDO1FBQ3pGO1FBQ0EsTUFBTU4sU0FBU2tGLElBQUk7SUFDdkI7SUFDQSxNQUFNc1AsY0FBYzNCLFNBQVMsRUFBRXpKLE1BQU0sRUFBRTtRQUNuQ3JJLFdBQVc4UjtRQUNYLE1BQU03UyxXQUFXLE1BQU0sSUFBSSxDQUFDcUQsTUFBTSxDQUFDc0IsSUFBSSxDQUFDQyxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUMzQixNQUFNLENBQUMsVUFBVSxFQUFFNFAsVUFBVSxDQUFDLEVBQUU7WUFDbkZoTyxRQUFRO1lBQ1J6RCxTQUFTO2dCQUFFLEdBQUcsSUFBSSxDQUFDQSxPQUFPO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUMvRGxCLE1BQU00RixLQUFLQyxTQUFTLENBQUNxRDtZQUNyQnRFLFFBQVFDLFlBQVlDLE9BQU8sQ0FBQyxJQUFJLENBQUM1QixVQUFVO1FBQy9DO1FBQ0EsSUFBSSxDQUFDcEQsU0FBU0ksRUFBRSxFQUFFO1lBQ2QsTUFBTSxJQUFJWixNQUFNLENBQUMseUJBQXlCLEVBQUVxVCxVQUFVLEVBQUUsRUFBRTdTLFNBQVNLLE1BQU0sQ0FBQyxDQUFDLEVBQUVMLFNBQVNNLFVBQVUsQ0FBQyxDQUFDO1FBQ3RHO1FBQ0EsTUFBTUcsU0FBUyxNQUFNVCxTQUFTa0YsSUFBSTtRQUNsQyxPQUFPekU7SUFDWDtJQUNBLE1BQU1nVSxZQUFZM1YsR0FBRyxFQUFFNFYsU0FBUyxFQUFFLEVBQUVDLFVBQVUsRUFBRXpKLGFBQWEsRUFBRTBKLGdCQUFnQixFQUFHLEdBQUc7UUFBRTFKLGVBQWU7SUFBTSxDQUFDLEVBQUU7UUFDM0csSUFBSWE7UUFDSixJQUFJLE9BQU9qTixRQUFRLFVBQVU7WUFDekJpTixPQUFPLE1BQU0sSUFBSSxDQUFDZCxPQUFPLENBQUNuTSxLQUFLO2dCQUFFb007WUFBYztRQUNuRCxPQUNLLElBQUksT0FBT3BNLFFBQVEsWUFBWSxRQUFRQSxLQUFLO1lBQzdDaU4sT0FBT2pOO1FBQ1gsT0FDSztZQUNELE1BQU0sSUFBSVUsTUFBTSxDQUFDLGtCQUFrQixFQUFFLE9BQU9WLElBQUksQ0FBQztRQUNyRDtRQUNBLElBQUlpTixLQUFLOEksb0JBQW9CLEtBQUssUUFDOUI5SSxLQUFLOEksb0JBQW9CLEtBQUt4VixXQUFXO1lBQ3pDdVYsbUJBQW1CLE1BQU0sSUFBSSxDQUFDWixXQUFXLENBQUNqSSxLQUFLOEksb0JBQW9CO1FBQ3ZFO1FBQ0EsTUFBTUMsaUJBQWlCLE1BQU1KLFVBQVVELFdBQVcsQ0FBQzFJLE1BQU02STtRQUN6RCxJQUFJRyxjQUFjSixjQUFjLENBQUM7UUFDakMsSUFBSUcsZUFBZUUsYUFBYSxFQUFFO1lBQzlCRCxjQUFjO2dCQUFFLEdBQUdBLFdBQVc7Z0JBQUUsR0FBR0QsZUFBZUUsYUFBYTtZQUFDO1FBQ3BFO1FBQ0EsTUFBTW5LLFFBQVFpSyxlQUFlRyxXQUFXLElBQUlsSixLQUFLdEYsRUFBRTtRQUNuRCxPQUFPLE1BQU0sSUFBSSxDQUFDeU8sY0FBYyxDQUFDckssT0FBT2lLLGVBQWV2SyxHQUFHLEVBQUU7WUFDeEQ0SyxPQUFPTCxnQkFBZ0JLO1lBQ3ZCblQsT0FBTzhTLGdCQUFnQjlTO1lBQ3ZCb1QsU0FBU04sZ0JBQWdCTTtZQUN6QkMsWUFBWVAsZ0JBQWdCTztZQUM1QlYsWUFBWUk7WUFDWk8sb0JBQW9CO1lBQ3BCQyxhQUFhVCxnQkFBZ0JTO1FBQ2pDO0lBQ0o7SUFDQSxNQUFNTCxlQUFlckssS0FBSyxFQUFFTixHQUFHLEVBQUUsRUFBRTRLLEtBQUssRUFBRW5ULEtBQUssRUFBRXFULFVBQVUsRUFBRUQsT0FBTyxFQUFFVCxVQUFVLEVBQUVXLHFCQUFxQixLQUFLLEVBQUVDLFdBQVcsRUFBRUMsVUFBVSxFQUFFQyxjQUFjLEVBQUcsRUFBRTtRQUN0SixNQUFNQyxrQkFBa0I7WUFDcEJDLE1BQU1MLHNCQUFzQjtZQUM1QnRXLFVBQVUyVixjQUFjLENBQUM7UUFDN0I7UUFDQSxJQUFJWSxnQkFBZ0JsVyxhQUNoQnFXLGlCQUFpQjFXLGFBQWFLLGFBQzlCLENBQUNxVyxnQkFBZ0IxVyxRQUFRLENBQUMsUUFBUSxFQUFFO1lBQ3BDMFcsZ0JBQWdCMVcsUUFBUSxDQUFDLFFBQVEsR0FBRztnQkFBRXdQLFFBQVErRztZQUFZO1FBQzlEO1FBQ0EsSUFBSUcsaUJBQWlCMVcsYUFBYUssYUFDOUJxVyxnQkFBZ0IxVyxRQUFRLENBQUMsUUFBUSxFQUFFd1AsV0FBV25QLFdBQVc7WUFDekQwQixXQUFXMlUsZ0JBQWdCMVcsUUFBUSxDQUFDLFFBQVEsQ0FBQ3dQLE1BQU07UUFDdkQ7UUFDQSxNQUFNb0gsV0FBVztZQUNiblAsSUFBSStPLGNBQWN2WCw0Q0FBTztZQUN6QnVRLFFBQVEzRDtZQUNSTjtZQUNBNEs7WUFDQW5UO1lBQ0FxVDtZQUNBRDtZQUNBTSxpQkFBaUJBO1lBQ2pCRDtRQUNKO1FBQ0EsTUFBTS9WLE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQ3VELE1BQU0sQ0FBQyxTQUFTLENBQUM7UUFDckMsTUFBTWpELFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU9sRixLQUFLO1lBQ2hEbUYsUUFBUTtZQUNSekQsU0FBUztnQkFBRSxHQUFHLElBQUksQ0FBQ0EsT0FBTztnQkFBRSxnQkFBZ0I7WUFBbUI7WUFDL0RsQixNQUFNNEYsS0FBS0MsU0FBUyxDQUFDNlA7WUFDckI5USxRQUFRQyxZQUFZQyxPQUFPLENBQUMsSUFBSSxDQUFDNUIsVUFBVTtRQUMvQztRQUNBLE1BQU1yRCxlQUFlQyxVQUFVO1FBQy9CLE9BQU80VjtJQUNYO0lBQ0EsTUFBTUMsZUFBZUwsVUFBVSxFQUFFLEVBQUVMLEtBQUssRUFBRW5ULEtBQUssRUFBRXFULFVBQVUsRUFBRUQsT0FBTyxFQUFHLEVBQUU7UUFDckUsTUFBTVUsaUJBQWlCLENBQUM7UUFDeEIsSUFBSVgsVUFBVTlWLGFBQWE4VixVQUFVLE1BQU07WUFDdkNXLGNBQWMsQ0FBQyxRQUFRLEdBQUdYO1FBQzlCO1FBQ0EsSUFBSW5ULFVBQVUzQyxhQUFhMkMsVUFBVSxNQUFNO1lBQ3ZDOFQsY0FBYyxDQUFDLFFBQVEsR0FBRzlUO1FBQzlCO1FBQ0EsSUFBSXFULGVBQWVoVyxhQUFhZ1csZUFBZSxNQUFNO1lBQ2pEUyxjQUFjLENBQUMsYUFBYSxHQUFHVDtRQUNuQztRQUNBLElBQUlELFlBQVkvVixhQUFhK1YsWUFBWSxNQUFNO1lBQzNDVSxjQUFjLENBQUMsVUFBVSxHQUFHVjtRQUNoQztRQUNBclUsV0FBV3lVO1FBQ1gsTUFBTXhWLFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzNCLE1BQU0sQ0FBQyxVQUFVLEVBQUV1UyxXQUFXLENBQUMsRUFBRTtZQUNwRjNRLFFBQVE7WUFDUnpELFNBQVM7Z0JBQUUsR0FBRyxJQUFJLENBQUNBLE9BQU87Z0JBQUUsZ0JBQWdCO1lBQW1CO1lBQy9EbEIsTUFBTTRGLEtBQUtDLFNBQVMsQ0FBQytQO1lBQ3JCaFIsUUFBUUMsWUFBWUMsT0FBTyxDQUFDLElBQUksQ0FBQzVCLFVBQVU7UUFDL0M7UUFDQSxNQUFNckQsZUFBZUMsVUFBVTtJQUNuQztJQUNBLE1BQU0rVixhQUFhUCxVQUFVLEVBQUU7UUFDM0J6VSxXQUFXeVU7UUFDWCxNQUFNalIsT0FBTyxDQUFDLFVBQVUsRUFBRWlSLFdBQVcsQ0FBQztRQUN0QyxNQUFNeFYsV0FBVyxNQUFNLElBQUksQ0FBQ2lGLElBQUksQ0FBQ1Y7UUFDakMsT0FBT3ZFO0lBQ1g7SUFDQSxNQUFNZ1csZUFBZVIsVUFBVSxFQUFFO1FBQzdCelUsV0FBV3lVO1FBQ1gsTUFBTWpSLE9BQU8sQ0FBQyxVQUFVLEVBQUVpUixXQUFXLENBQUM7UUFDdEMsTUFBTXhWLFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU8sSUFBSSxDQUFDM0IsTUFBTSxHQUFHc0IsTUFBTTtZQUMvRE0sUUFBUTtZQUNSekQsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckIwRCxRQUFRQyxZQUFZQyxPQUFPLENBQUMsSUFBSSxDQUFDNUIsVUFBVTtRQUMvQztRQUNBLElBQUksQ0FBQ3BELFNBQVNJLEVBQUUsRUFBRTtZQUNkLE1BQU0sSUFBSVosTUFBTSxDQUFDLGlCQUFpQixFQUFFK0UsS0FBSyxFQUFFLEVBQUV2RSxTQUFTSyxNQUFNLENBQUMsQ0FBQyxFQUFFTCxTQUFTTSxVQUFVLENBQUMsQ0FBQztRQUN6RjtRQUNBLE1BQU1OLFNBQVNrRixJQUFJO0lBQ3ZCO0lBQ0EsT0FBTytRLGFBQWEsRUFBRWxILE1BQU0sRUFBRW1ILFlBQVksRUFBRUMsbUJBQW1CLEVBQUcsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUNyRSxNQUFNM1IsY0FBYyxJQUFJWTtRQUN4QixJQUFJMkosUUFBUTtZQUNSdkssWUFBWXdLLE1BQU0sQ0FBQyxPQUFPRCxPQUFPcUgsSUFBSSxDQUFDO1FBQzFDO1FBQ0EsSUFBSUYsY0FBYztZQUNkLEtBQUssTUFBTTNMLE9BQU8yTCxhQUFjO2dCQUM1QjFSLFlBQVl3SyxNQUFNLENBQUMsT0FBT3pFO1lBQzlCO1FBQ0o7UUFDQSxJQUFJNEwscUJBQXFCO1lBQ3JCLEtBQUssTUFBTVIsUUFBUVEsb0JBQXFCO2dCQUNwQzNSLFlBQVl3SyxNQUFNLENBQUMsVUFBVTJHO1lBQ2pDO1FBQ0o7UUFDQSxXQUFXLE1BQU1VLGFBQWEsSUFBSSxDQUFDbFIsYUFBYSxDQUFDLGFBQWFYLGFBQWM7WUFDeEUsT0FBTzZSO1FBQ1g7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7OztLQWNDLEdBQ0QsTUFBTUMsNkJBQTZCekwsS0FBSyxFQUFFMEwsV0FBVyxFQUFFLEVBQUVDLFVBQVUsRUFBRWYsY0FBYyxFQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDekYsTUFBTXZWLE9BQU87WUFDVHNPLFFBQVEzRDtZQUNSNEwsY0FBY0Y7WUFDZEcsaUJBQWlCakI7UUFDckI7UUFDQSxJQUFJZSxZQUFZO1lBQ1osSUFBSSxPQUFPQSxlQUFlLFVBQVU7Z0JBQ2hDdFcsSUFBSSxDQUFDLGFBQWEsR0FBR3NXO1lBQ3pCLE9BQ0ssSUFBSUEsWUFBWUcsU0FBU0gsWUFBWUksV0FBV0osWUFBWUssTUFBTTtnQkFDbkUzVyxJQUFJLENBQUMsYUFBYSxHQUFHc1c7WUFDekI7UUFDSixPQUNLO1lBQ0R0VyxJQUFJLENBQUMsYUFBYSxHQUFHO2dCQUNqQnlXLE9BQU87WUFDWDtRQUNKO1FBQ0EsTUFBTTNXLFdBQVcsTUFBTSxJQUFJLENBQUNxRCxNQUFNLENBQUNzQixJQUFJLENBQUNDLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzNCLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO1lBQzdFNEIsUUFBUTtZQUNSekQsU0FBUztnQkFBRSxHQUFHLElBQUksQ0FBQ0EsT0FBTztnQkFBRSxnQkFBZ0I7WUFBbUI7WUFDL0RsQixNQUFNNEYsS0FBS0MsU0FBUyxDQUFDN0Y7WUFDckI0RSxRQUFRQyxZQUFZQyxPQUFPLENBQUMsSUFBSSxDQUFDNUIsVUFBVTtRQUMvQztRQUNBLE1BQU0zQyxTQUFTLE1BQU1ULFNBQVNrRixJQUFJO1FBQ2xDLE9BQU96RTtJQUNYO0lBQ0E7Ozs7S0FJQyxHQUNELE9BQU9xVyw0QkFBNEJqTSxLQUFLLEVBQUU7UUFDdEM5SixXQUFXOEo7UUFDWCxNQUFNdEIsU0FBUyxJQUFJbkUsZ0JBQWdCO1lBQUVvSixRQUFRM0Q7UUFBTTtRQUNuRCxXQUFXLE1BQU1rTSxVQUFVLElBQUksQ0FBQzVSLGFBQWEsQ0FBQyxvQkFBb0JvRSxRQUFTO1lBQ3ZFLE9BQU93TjtRQUNYO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWZvcm0tYnVpbGRlci10dXRvcmlhbC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9jbGllbnQuanM/ZWQxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBBc3luY0NhbGxlciB9IGZyb20gXCIuL3V0aWxzL2FzeW5jX2NhbGxlci5qc1wiO1xuaW1wb3J0IHsgY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUsIGlzTGFuZ0NoYWluTWVzc2FnZSwgfSBmcm9tIFwiLi91dGlscy9tZXNzYWdlcy5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSwgZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhLCBnZXRSdW50aW1lRW52aXJvbm1lbnQsIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBfX3ZlcnNpb25fXyB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5hc3luYyBmdW5jdGlvbiBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuQ3JlYXRlcyhydW5zKSB7XG4gICAgY29uc3QgcnVudGltZUVudiA9IGF3YWl0IGdldFJ1bnRpbWVFbnZpcm9ubWVudCgpO1xuICAgIGNvbnN0IGVudlZhcnMgPSBnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEoKTtcbiAgICByZXR1cm4gcnVucy5tYXAoKHJ1bikgPT4ge1xuICAgICAgICBjb25zdCBleHRyYSA9IHJ1bi5leHRyYSA/PyB7fTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBleHRyYS5tZXRhZGF0YTtcbiAgICAgICAgcnVuLmV4dHJhID0ge1xuICAgICAgICAgICAgLi4uZXh0cmEsXG4gICAgICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAgICAgLi4ucnVudGltZUVudixcbiAgICAgICAgICAgICAgICAuLi5leHRyYT8ucnVudGltZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIC4uLmVudlZhcnMsXG4gICAgICAgICAgICAgICAgLi4uKGVudlZhcnMucmV2aXNpb25faWQgfHwgcnVuLnJldmlzaW9uX2lkXG4gICAgICAgICAgICAgICAgICAgID8geyByZXZpc2lvbl9pZDogcnVuLnJldmlzaW9uX2lkID8/IGVudlZhcnMucmV2aXNpb25faWQgfVxuICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfSk7XG59XG5jb25zdCBnZXRUcmFjaW5nU2FtcGxpbmdSYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNhbXBsaW5nUmF0ZVN0ciA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fVFJBQ0lOR19TQU1QTElOR19SQVRFXCIpO1xuICAgIGlmIChzYW1wbGluZ1JhdGVTdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzYW1wbGluZ1JhdGUgPSBwYXJzZUZsb2F0KHNhbXBsaW5nUmF0ZVN0cik7XG4gICAgaWYgKHNhbXBsaW5nUmF0ZSA8IDAgfHwgc2FtcGxpbmdSYXRlID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExBTkdDSEFJTl9UUkFDSU5HX1NBTVBMSU5HX1JBVEUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEgaWYgc2V0LiBHb3Q6ICR7c2FtcGxpbmdSYXRlfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2FtcGxpbmdSYXRlO1xufTtcbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5jb25zdCBpc0xvY2FsaG9zdCA9ICh1cmwpID0+IHtcbiAgICBjb25zdCBzdHJpcHBlZFVybCA9IHVybC5yZXBsYWNlKFwiaHR0cDovL1wiLCBcIlwiKS5yZXBsYWNlKFwiaHR0cHM6Ly9cIiwgXCJcIik7XG4gICAgY29uc3QgaG9zdG5hbWUgPSBzdHJpcHBlZFVybC5zcGxpdChcIi9cIilbMF0uc3BsaXQoXCI6XCIpWzBdO1xuICAgIHJldHVybiAoaG9zdG5hbWUgPT09IFwibG9jYWxob3N0XCIgfHwgaG9zdG5hbWUgPT09IFwiMTI3LjAuMC4xXCIgfHwgaG9zdG5hbWUgPT09IFwiOjoxXCIpO1xufTtcbmNvbnN0IHJhaXNlRm9yU3RhdHVzID0gYXN5bmMgKHJlc3BvbnNlLCBvcGVyYXRpb24pID0+IHtcbiAgICAvLyBjb25zdW1lIHRoZSByZXNwb25zZSBib2R5IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAvLyBodHRwczovL3VuZGljaS5ub2RlanMub3JnLyMvP2lkPWdhcmJhZ2UtY29sbGVjdGlvblxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byAke29wZXJhdGlvbn06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICR7Ym9keX1gKTtcbiAgICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gdG9BcnJheShpdGVyYWJsZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBpdGVyYWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRyaW1RdW90ZXMoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAucmVwbGFjZSgvXlwiKC4qKVwiJC8sIFwiJDFcIilcbiAgICAgICAgLnJlcGxhY2UoL14nKC4qKSckLywgXCIkMVwiKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFV1aWQoc3RyKSB7XG4gICAgaWYgKCF1dWlkLnZhbGlkYXRlKHN0cikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVVSUQ6ICR7c3RyfWApO1xuICAgIH1cbn1cbmNvbnN0IGhhbmRsZTQyOSA9IGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgIGlmIChyZXNwb25zZT8uc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwicmV0cnktYWZ0ZXJcIikgPz8gXCIzMFwiLCAxMCkgKiAxMDAwO1xuICAgICAgICBpZiAocmV0cnlBZnRlciA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5QWZ0ZXIpKTtcbiAgICAgICAgICAgIC8vIFJldHVybiBkaXJlY3RseSBhZnRlciBjYWxsaW5nIHRoaXMgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZhbGwgYmFjayB0byBleGlzdGluZyBzdGF0dXMgY2hlY2tzXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydCBjbGFzcyBRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIml0ZW1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICB9XG4gICAgcHVzaChpdGVtKSB7XG4gICAgICAgIC8vIHRoaXMuaXRlbXMucHVzaCBpcyBzeW5jaHJvbm91cyB3aXRoIHByb21pc2UgY3JlYXRpb246XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2UvUHJvbWlzZVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChbaXRlbSwgcmVzb2x2ZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9wKHVwVG9OKSB7XG4gICAgICAgIGlmICh1cFRvTiA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBvZiBpdGVtcyB0byBwb3Agb2ZmIG1heSBub3QgYmUgbGVzcyB0aGFuIDEuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcHBlZCA9IFtdO1xuICAgICAgICB3aGlsZSAocG9wcGVkLmxlbmd0aCA8IHVwVG9OICYmIHRoaXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBwb3BwZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcG9wcGVkLm1hcCgoaXQpID0+IGl0WzBdKSwgKCkgPT4gcG9wcGVkLmZvckVhY2goKGl0KSA9PiBpdFsxXSgpKV07XG4gICAgfVxufVxuLy8gMjAgTUJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0JBVENIX1NJWkVfTElNSVRfQllURVMgPSAyMDk3MTUyMDtcbmV4cG9ydCBjbGFzcyBDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaUtleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid2ViVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaEluZ2VzdENhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aW1lb3V0X21zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90ZW5hbnRJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGlkZUlucHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoaWRlT3V0cHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjaW5nU2FtcGxlUmF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzYW1wbGVkUG9zdFV1aWRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFRyYWNpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhdGNoRW5kcG9pbnRTdXBwb3J0ZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoUXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBRdWV1ZSgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMTAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hUaW1lb3V0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaEluaXRpYWxEZWxheU1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAyNTBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaEFnZ3JlZ2F0aW9uRGVsYXlNc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNTBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcnZlckluZm9cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IENsaWVudC5nZXREZWZhdWx0Q2xpZW50Q29uZmlnKCk7XG4gICAgICAgIHRoaXMudHJhY2luZ1NhbXBsZVJhdGUgPSBnZXRUcmFjaW5nU2FtcGxpbmdSYXRlKCk7XG4gICAgICAgIHRoaXMuYXBpVXJsID0gdHJpbVF1b3Rlcyhjb25maWcuYXBpVXJsID8/IGRlZmF1bHRDb25maWcuYXBpVXJsKSA/PyBcIlwiO1xuICAgICAgICB0aGlzLmFwaUtleSA9IHRyaW1RdW90ZXMoY29uZmlnLmFwaUtleSA/PyBkZWZhdWx0Q29uZmlnLmFwaUtleSk7XG4gICAgICAgIHRoaXMud2ViVXJsID0gdHJpbVF1b3Rlcyhjb25maWcud2ViVXJsID8/IGRlZmF1bHRDb25maWcud2ViVXJsKTtcbiAgICAgICAgdGhpcy50aW1lb3V0X21zID0gY29uZmlnLnRpbWVvdXRfbXMgPz8gMTIwMDA7XG4gICAgICAgIHRoaXMuY2FsbGVyID0gbmV3IEFzeW5jQ2FsbGVyKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KTtcbiAgICAgICAgdGhpcy5iYXRjaEluZ2VzdENhbGxlciA9IG5ldyBBc3luY0NhbGxlcih7XG4gICAgICAgICAgICAuLi4oY29uZmlnLmNhbGxlck9wdGlvbnMgPz8ge30pLFxuICAgICAgICAgICAgb25GYWlsZWRSZXNwb25zZUhvb2s6IGhhbmRsZTQyOSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGlkZUlucHV0cyA9IGNvbmZpZy5oaWRlSW5wdXRzID8/IGRlZmF1bHRDb25maWcuaGlkZUlucHV0cztcbiAgICAgICAgdGhpcy5oaWRlT3V0cHV0cyA9IGNvbmZpZy5oaWRlT3V0cHV0cyA/PyBkZWZhdWx0Q29uZmlnLmhpZGVPdXRwdXRzO1xuICAgICAgICB0aGlzLmF1dG9CYXRjaFRyYWNpbmcgPSBjb25maWcuYXV0b0JhdGNoVHJhY2luZyA/PyB0aGlzLmF1dG9CYXRjaFRyYWNpbmc7XG4gICAgICAgIHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQgPVxuICAgICAgICAgICAgY29uZmlnLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bkxpbWl0ID8/IHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q2xpZW50Q29uZmlnKCkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0FQSV9LRVlcIik7XG4gICAgICAgIGNvbnN0IGFwaVVybCA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIikgPz9cbiAgICAgICAgICAgIFwiaHR0cHM6Ly9hcGkuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICBjb25zdCBoaWRlSW5wdXRzID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9ISURFX0lOUFVUU1wiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIGNvbnN0IGhpZGVPdXRwdXRzID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9ISURFX09VVFBVVFNcIikgPT09IFwidHJ1ZVwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBpVXJsOiBhcGlVcmwsXG4gICAgICAgICAgICBhcGlLZXk6IGFwaUtleSxcbiAgICAgICAgICAgIHdlYlVybDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGlkZUlucHV0czogaGlkZUlucHV0cyxcbiAgICAgICAgICAgIGhpZGVPdXRwdXRzOiBoaWRlT3V0cHV0cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0SG9zdFVybCgpIHtcbiAgICAgICAgaWYgKHRoaXMud2ViVXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNMb2NhbGhvc3QodGhpcy5hcGlVcmwpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cDovL2xvY2FsaG9zdFwiO1xuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cDovL2xvY2FsaG9zdFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLmluY2x1ZGVzKFwiL2FwaVwiKSAmJlxuICAgICAgICAgICAgIXRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5lbmRzV2l0aChcImFwaVwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSB0aGlzLmFwaVVybC5yZXBsYWNlKFwiL2FwaVwiLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uaW5jbHVkZXMoXCJkZXZcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL2Rldi5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovL2Rldi5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovL3NtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIFwiVXNlci1BZ2VudFwiOiBgbGFuZ3NtaXRoLWpzLyR7X192ZXJzaW9uX199YCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC1hcGkta2V5XCJdID0gYCR7dGhpcy5hcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgcHJvY2Vzc0lucHV0cyhpbnB1dHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlkZUlucHV0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGlkZUlucHV0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5oaWRlSW5wdXRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH1cbiAgICBwcm9jZXNzT3V0cHV0cyhvdXRwdXRzKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZGVPdXRwdXRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGlkZU91dHB1dHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaGlkZU91dHB1dHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZU91dHB1dHMob3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIHByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyhydW4pIHtcbiAgICAgICAgY29uc3QgcnVuUGFyYW1zID0geyAuLi5ydW4gfTtcbiAgICAgICAgaWYgKHJ1blBhcmFtcy5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuUGFyYW1zLmlucHV0cyA9IHRoaXMucHJvY2Vzc0lucHV0cyhydW5QYXJhbXMuaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuUGFyYW1zLm91dHB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuUGFyYW1zLm91dHB1dHMgPSB0aGlzLnByb2Nlc3NPdXRwdXRzKHJ1blBhcmFtcy5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuUGFyYW1zO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0UmVzcG9uc2UocGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zU3RyaW5nID0gcXVlcnlQYXJhbXM/LnRvU3RyaW5nKCkgPz8gXCJcIjtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3BhcmFtc1N0cmluZ31gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke3BhdGh9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldChwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldFJlc3BvbnNlKHBhdGgsIHF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgKl9nZXRQYWdpbmF0ZWQocGF0aCwgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCkpIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IE51bWJlcihxdWVyeVBhcmFtcy5nZXQoXCJvZmZzZXRcIikpIHx8IDA7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gTnVtYmVyKHF1ZXJ5UGFyYW1zLmdldChcImxpbWl0XCIpKSB8fCAxMDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5zZXQoXCJvZmZzZXRcIiwgU3RyaW5nKG9mZnNldCkpO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2V0KFwibGltaXRcIiwgU3RyaW5nKGxpbWl0KSk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cXVlcnlQYXJhbXN9YDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgdXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoICR7cGF0aH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGl0ZW1zO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpfZ2V0Q3Vyc29yUGFnaW5hdGVkTGlzdChwYXRoLCBib2R5ID0gbnVsbCwgcmVxdWVzdE1ldGhvZCA9IFwiUE9TVFwiLCBkYXRhS2V5ID0gXCJydW5zXCIpIHtcbiAgICAgICAgY29uc3QgYm9keVBhcmFtcyA9IGJvZHkgPyB7IC4uLmJvZHkgfSA6IHt9O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdE1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5UGFyYW1zKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VCb2R5W2RhdGFLZXldKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCByZXNwb25zZUJvZHlbZGF0YUtleV07XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JzID0gcmVzcG9uc2VCb2R5LmN1cnNvcnM7XG4gICAgICAgICAgICBpZiAoIWN1cnNvcnMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3Vyc29ycy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5UGFyYW1zLmN1cnNvciA9IGN1cnNvcnMubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZmlsdGVyRm9yU2FtcGxpbmcocnVucywgcGF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVucztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuIG9mIHJ1bnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zYW1wbGVkUG9zdFV1aWRzLmhhcyhydW4uaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZWRQb3N0VXVpZHMuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVkID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1biBvZiBydW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCB0aGlzLnRyYWNpbmdTYW1wbGVSYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZWRQb3N0VXVpZHMuYWRkKHJ1bi5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZHJhaW5BdXRvQmF0Y2hRdWV1ZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuYXV0b0JhdGNoUXVldWUuc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBbYmF0Y2gsIGRvbmVdID0gdGhpcy5hdXRvQmF0Y2hRdWV1ZS5wb3AodGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdCk7XG4gICAgICAgICAgICBpZiAoIWJhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYmF0Y2hJbmdlc3RSdW5zKHtcbiAgICAgICAgICAgICAgICAgICAgcnVuQ3JlYXRlczogYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcImNyZWF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgcnVuVXBkYXRlczogYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcInVwZGF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pdGVtKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzUnVuT3BlcmF0aW9uKGl0ZW0sIGltbWVkaWF0ZWx5VHJpZ2dlckJhdGNoKSB7XG4gICAgICAgIGNvbnN0IG9sZFRpbWVvdXQgPSB0aGlzLmF1dG9CYXRjaFRpbWVvdXQ7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmF1dG9CYXRjaFRpbWVvdXQpO1xuICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGl0ZW1Qcm9taXNlID0gdGhpcy5hdXRvQmF0Y2hRdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICBpZiAoaW1tZWRpYXRlbHlUcmlnZ2VyQmF0Y2ggfHxcbiAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoUXVldWUuc2l6ZSA+IHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9CYXRjaFF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBlcnJvciB3b3VsZCBoYXBwZW4gaW4gdGhlIGJhY2tncm91bmQgYW5kIGlzIHVuY2F0Y2hhYmxlXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3V0c2lkZS4gU28ganVzdCBsb2cgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSgpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgfSwgb2xkVGltZW91dFxuICAgICAgICAgICAgICAgID8gdGhpcy5hdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXNcbiAgICAgICAgICAgICAgICA6IHRoaXMuYXV0b0JhdGNoSW5pdGlhbERlbGF5TXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFNlcnZlckluZm8oKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2luZm9gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAvLyBodHRwczovL3VuZGljaS5ub2RlanMub3JnLyMvP2lkPWdhcmJhZ2UtY29sbGVjdGlvblxuICAgICAgICAgICAgYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHJldHJpZXZlIHNlcnZlciBpbmZvLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaEVuZHBvaW50SXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJJbmZvKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUnVuKHJ1bikge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKFtydW5dKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG4gICAgICAgIGNvbnN0IHNlc3Npb25fbmFtZSA9IHJ1bi5wcm9qZWN0X25hbWU7XG4gICAgICAgIGRlbGV0ZSBydW4ucHJvamVjdF9uYW1lO1xuICAgICAgICBjb25zdCBydW5DcmVhdGUgPSB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyh7XG4gICAgICAgICAgICBzZXNzaW9uX25hbWUsXG4gICAgICAgICAgICAuLi5ydW4sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBydW4uc3RhcnRfdGltZSA/PyBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoVHJhY2luZyAmJlxuICAgICAgICAgICAgcnVuQ3JlYXRlLnRyYWNlX2lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHJ1bkNyZWF0ZS5kb3R0ZWRfb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdm9pZCB0aGlzLnByb2Nlc3NSdW5PcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJjcmVhdGVcIixcbiAgICAgICAgICAgICAgICBpdGVtOiBydW5DcmVhdGUsXG4gICAgICAgICAgICB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXJnZWRSdW5DcmVhdGVQYXJhbXMgPSBhd2FpdCBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuQ3JlYXRlcyhbXG4gICAgICAgICAgICBydW5DcmVhdGUsXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtZXJnZWRSdW5DcmVhdGVQYXJhbXNbMF0pLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgcnVuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaCBpbmdlc3QvdXBzZXJ0IG11bHRpcGxlIHJ1bnMgaW4gdGhlIExhbmdzbWl0aCBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHJ1bnNcbiAgICAgKi9cbiAgICBhc3luYyBiYXRjaEluZ2VzdFJ1bnMoeyBydW5DcmVhdGVzLCBydW5VcGRhdGVzLCB9KSB7XG4gICAgICAgIGlmIChydW5DcmVhdGVzID09PSB1bmRlZmluZWQgJiYgcnVuVXBkYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gcnVuQ3JlYXRlcz8ubWFwKChjcmVhdGUpID0+IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKGNyZWF0ZSkpID8/IFtdO1xuICAgICAgICBsZXQgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBydW5VcGRhdGVzPy5tYXAoKHVwZGF0ZSkgPT4gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHModXBkYXRlKSkgPz8gW107XG4gICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZVBhcmFtcy5sZW5ndGggPiAwICYmIHByZXBhcmVkVXBkYXRlUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJ5SWQgPSBwcmVwYXJlZENyZWF0ZVBhcmFtcy5yZWR1Y2UoKHBhcmFtcywgcnVuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFydW4uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zW3J1bi5pZF0gPSBydW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYWxvbmVVcGRhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZVBhcmFtIG9mIHByZXBhcmVkVXBkYXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVBhcmFtLmlkICE9PSB1bmRlZmluZWQgJiYgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZVBhcmFtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhbG9uZVVwZGF0ZXMucHVzaCh1cGRhdGVQYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBPYmplY3QudmFsdWVzKGNyZWF0ZUJ5SWQpO1xuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBzdGFuZGFsb25lVXBkYXRlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdCYXRjaCA9IHtcbiAgICAgICAgICAgIHBvc3Q6IHRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKHByZXBhcmVkQ3JlYXRlUGFyYW1zKSxcbiAgICAgICAgICAgIHBhdGNoOiB0aGlzLl9maWx0ZXJGb3JTYW1wbGluZyhwcmVwYXJlZFVwZGF0ZVBhcmFtcywgdHJ1ZSksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmF3QmF0Y2gucG9zdC5sZW5ndGggJiYgIXJhd0JhdGNoLnBhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gYXdhaXQgbWVyZ2VSdW50aW1lRW52SW50b1J1bkNyZWF0ZXMocHJlcGFyZWRDcmVhdGVQYXJhbXMpO1xuICAgICAgICBpZiAodGhpcy5iYXRjaEVuZHBvaW50U3VwcG9ydGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hFbmRwb2ludFN1cHBvcnRlZCA9IGF3YWl0IHRoaXMuYmF0Y2hFbmRwb2ludElzU3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmJhdGNoRW5kcG9pbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoVHJhY2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVwYXJlZENyZWF0ZVBhcmFtIG9mIHJhd0JhdGNoLnBvc3QpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVJ1bihwcmVwYXJlZENyZWF0ZVBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlcGFyZWRVcGRhdGVQYXJhbSBvZiByYXdCYXRjaC5wYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVwYXJlZFVwZGF0ZVBhcmFtLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVSdW4ocHJlcGFyZWRVcGRhdGVQYXJhbS5pZCwgcHJlcGFyZWRVcGRhdGVQYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpemVMaW1pdEJ5dGVzID0gdGhpcy5zZXJ2ZXJJbmZvPy5iYXRjaF9pbmdlc3RfY29uZmlnPy5zaXplX2xpbWl0X2J5dGVzID8/XG4gICAgICAgICAgICBERUZBVUxUX0JBVENIX1NJWkVfTElNSVRfQllURVM7XG4gICAgICAgIGNvbnN0IGJhdGNoQ2h1bmtzID0ge1xuICAgICAgICAgICAgcG9zdDogW10sXG4gICAgICAgICAgICBwYXRjaDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjdXJyZW50QmF0Y2hTaXplQnl0ZXMgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgW1wicG9zdFwiLCBcInBhdGNoXCJdKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hJdGVtcyA9IHJhd0JhdGNoW2tleV0ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbGV0IGJhdGNoSXRlbSA9IGJhdGNoSXRlbXMucG9wKCk7XG4gICAgICAgICAgICB3aGlsZSAoYmF0Y2hJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEJhdGNoSXRlbSA9IEpTT04uc3RyaW5naWZ5KGJhdGNoSXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCYXRjaFNpemVCeXRlcyA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEJhdGNoU2l6ZUJ5dGVzICsgc3RyaW5naWZpZWRCYXRjaEl0ZW0ubGVuZ3RoID4gc2l6ZUxpbWl0Qnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcG9zdEJhdGNoSW5nZXN0UnVucyhKU09OLnN0cmluZ2lmeShiYXRjaENodW5rcykpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QmF0Y2hTaXplQnl0ZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBiYXRjaENodW5rcy5wb3N0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoQ2h1bmtzLnBhdGNoID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRCYXRjaFNpemVCeXRlcyArPSBzdHJpbmdpZmllZEJhdGNoSXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYmF0Y2hDaHVua3Nba2V5XS5wdXNoKGJhdGNoSXRlbSk7XG4gICAgICAgICAgICAgICAgYmF0Y2hJdGVtID0gYmF0Y2hJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmF0Y2hDaHVua3MucG9zdC5sZW5ndGggPiAwIHx8IGJhdGNoQ2h1bmtzLnBhdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Bvc3RCYXRjaEluZ2VzdFJ1bnMoSlNPTi5zdHJpbmdpZnkoYmF0Y2hDaHVua3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcG9zdEJhdGNoSW5nZXN0UnVucyhib2R5KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5iYXRjaEluZ2VzdENhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVucy9iYXRjaGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiYmF0Y2ggY3JlYXRlIHJ1blwiKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUnVuKHJ1bklkLCBydW4pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGlmIChydW4uaW5wdXRzKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gdGhpcy5wcm9jZXNzSW5wdXRzKHJ1bi5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW4ub3V0cHV0cykge1xuICAgICAgICAgICAgcnVuLm91dHB1dHMgPSB0aGlzLnByb2Nlc3NPdXRwdXRzKHJ1bi5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBVbnRhbmdsZSB0eXBlc1xuICAgICAgICBjb25zdCBkYXRhID0geyAuLi5ydW4sIGlkOiBydW5JZCB9O1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKFtkYXRhXSwgdHJ1ZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoVHJhY2luZyAmJlxuICAgICAgICAgICAgZGF0YS50cmFjZV9pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBkYXRhLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocnVuLmVuZF90aW1lICE9PSB1bmRlZmluZWQgJiYgZGF0YS5wYXJlbnRfcnVuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGEgYmF0Y2ggYXMgc29vbiBhcyBhIHJvb3QgdHJhY2UgZW5kcyBhbmQgYmxvY2sgdG8gZW5zdXJlIHRyYWNlIGZpbmlzaGVzXG4gICAgICAgICAgICAgICAgLy8gaW4gc2VydmVybGVzcyBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzUnVuT3BlcmF0aW9uKHsgYWN0aW9uOiBcInVwZGF0ZVwiLCBpdGVtOiBkYXRhIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5wcm9jZXNzUnVuT3BlcmF0aW9uKHsgYWN0aW9uOiBcInVwZGF0ZVwiLCBpdGVtOiBkYXRhIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJ1biksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBydW5cIik7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRSdW4ocnVuSWQsIHsgbG9hZENoaWxkUnVucyB9ID0geyBsb2FkQ2hpbGRSdW5zOiBmYWxzZSB9KSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBsZXQgcnVuID0gYXdhaXQgdGhpcy5fZ2V0KGAvcnVucy8ke3J1bklkfWApO1xuICAgICAgICBpZiAobG9hZENoaWxkUnVucyAmJiBydW4uY2hpbGRfcnVuX2lkcykge1xuICAgICAgICAgICAgcnVuID0gYXdhaXQgdGhpcy5fbG9hZENoaWxkUnVucyhydW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blVybCh7IHJ1bklkLCBydW4sIHByb2plY3RPcHRzLCB9KSB7XG4gICAgICAgIGlmIChydW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHNlc3Npb25JZDtcbiAgICAgICAgICAgIGlmIChydW4uc2Vzc2lvbl9pZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHJ1bi5zZXNzaW9uX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvamVjdE9wdHM/LnByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gKGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogcHJvamVjdE9wdHM/LnByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2plY3RPcHRzPy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBwcm9qZWN0T3B0cz8ucHJvamVjdElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IGF3YWl0IHRoaXMucmVhZFByb2plY3Qoe1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9QUk9KRUNUXCIpIHx8IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHByb2plY3QuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGF3YWl0IHRoaXMuX2dldFRlbmFudElkKCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vcHJvamVjdHMvcC8ke3Nlc3Npb25JZH0vci8ke3J1bi5pZH0/cG9sbD10cnVlYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW5JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBydW5fID0gYXdhaXQgdGhpcy5yZWFkUnVuKHJ1bklkKTtcbiAgICAgICAgICAgIGlmICghcnVuXy5hcHBfcGF0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUnVuICR7cnVuSWR9IGhhcyBubyBhcHBfcGF0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0SG9zdFVybCgpO1xuICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9JHtydW5fLmFwcF9wYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHJ1bklkIG9yIHJ1blwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbG9hZENoaWxkUnVucyhydW4pIHtcbiAgICAgICAgY29uc3QgY2hpbGRSdW5zID0gYXdhaXQgdG9BcnJheSh0aGlzLmxpc3RSdW5zKHsgaWQ6IHJ1bi5jaGlsZF9ydW5faWRzIH0pKTtcbiAgICAgICAgY29uc3QgdHJlZW1hcCA9IHt9O1xuICAgICAgICBjb25zdCBydW5zID0ge307XG4gICAgICAgIC8vIFRPRE86IG1ha2UgZG90dGVkIG9yZGVyIHJlcXVpcmVkIHdoZW4gdGhlIG1pZ3JhdGlvbiBmaW5pc2hlc1xuICAgICAgICBjaGlsZFJ1bnMuc29ydCgoYSwgYikgPT4gKGE/LmRvdHRlZF9vcmRlciA/PyBcIlwiKS5sb2NhbGVDb21wYXJlKGI/LmRvdHRlZF9vcmRlciA/PyBcIlwiKSk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRSdW4gb2YgY2hpbGRSdW5zKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRSdW4ucGFyZW50X3J1bl9pZCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIGNoaWxkUnVuLnBhcmVudF9ydW5faWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hpbGQgcnVuICR7Y2hpbGRSdW4uaWR9IGhhcyBubyBwYXJlbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGNoaWxkUnVuLnBhcmVudF9ydW5faWQgaW4gdHJlZW1hcCkpIHtcbiAgICAgICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdLnB1c2goY2hpbGRSdW4pO1xuICAgICAgICAgICAgcnVuc1tjaGlsZFJ1bi5pZF0gPSBjaGlsZFJ1bjtcbiAgICAgICAgfVxuICAgICAgICBydW4uY2hpbGRfcnVucyA9IHRyZWVtYXBbcnVuLmlkXSB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCBydW5JZCBpbiB0cmVlbWFwKSB7XG4gICAgICAgICAgICBpZiAocnVuSWQgIT09IHJ1bi5pZCkge1xuICAgICAgICAgICAgICAgIHJ1bnNbcnVuSWRdLmNoaWxkX3J1bnMgPSB0cmVlbWFwW3J1bklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHJ1bnMgZnJvbSB0aGUgTGFuZ1NtaXRoIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gcHJvamVjdElkIC0gVGhlIElEIG9mIHRoZSBwcm9qZWN0IHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcHJvamVjdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHBhcmVudFJ1bklkIC0gVGhlIElEIG9mIHRoZSBwYXJlbnQgcnVuIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gdHJhY2VJZCAtIFRoZSBJRCBvZiB0aGUgdHJhY2UgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSByZWZlcmVuY2VFeGFtcGxlSWQgLSBUaGUgSUQgb2YgdGhlIHJlZmVyZW5jZSBleGFtcGxlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIC0gVGhlIHN0YXJ0IHRpbWUgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBleGVjdXRpb25PcmRlciAtIFRoZSBleGVjdXRpb24gb3JkZXIgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBydW5UeXBlIC0gVGhlIHJ1biB0eXBlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBJbmRpY2F0ZXMgd2hldGhlciB0byBmaWx0ZXIgYnkgZXJyb3IgcnVucy5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhlIHJ1biB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHN0cmluZyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIGZpbHRlciAtIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IHRvIHRoZSBydW4gc3BhbnMuXG4gICAgICogQHBhcmFtIHRyYWNlRmlsdGVyIC0gVGhlIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgb24gdGhlIHJvb3QgcnVuIG9mIHRoZSB0cmFjZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcnVucyB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxSdW4+fSAtIFRoZSBydW5zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIGluIGEgcHJvamVjdFxuICAgICAqIGNvbnN0IHByb2plY3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHsgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBMTE0gYW5kIENoYXQgcnVucyBpbiB0aGUgbGFzdCAyNCBob3Vyc1xuICAgICAqIGNvbnN0IHRvZGF5c0xMTVJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIHN0YXJ0X3RpbWU6IG5ldyBEYXRlKERhdGUubm93KCkgLSAyNCAqIDYwICogNjAgKiAxMDAwKSxcbiAgICAgKiAgIHJ1bl90eXBlOiBcImxsbVwiLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHRyYWNlcyBpbiBhIHByb2plY3RcbiAgICAgKiBjb25zdCByb290UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZXhlY3V0aW9uX29yZGVyOiAxLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHJ1bnMgd2l0aG91dCBlcnJvcnNcbiAgICAgKiBjb25zdCBjb3JyZWN0UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZXJyb3I6IGZhbHNlLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHJ1bnMgYnkgcnVuIElEXG4gICAgICogY29uc3QgcnVuSWRzID0gW1xuICAgICAqICAgXCJhMzYwOTJkMi00YWQ1LTRmYjQtOWMwZC0wZGJhOWEyZWQ4MzZcIixcbiAgICAgKiAgIFwiOTM5OGU2YmUtOTY0Zi00YWE0LThhZTktYWQ3OGNkNGI3MDc0XCIsXG4gICAgICogXTtcbiAgICAgKiBjb25zdCBzZWxlY3RlZFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoeyBydW5faWRzOiBydW5JZHMgfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIFwiY2hhaW5cIiB0eXBlIHJ1bnMgdGhhdCB0b29rIG1vcmUgdGhhbiAxMCBzZWNvbmRzIGFuZCBoYWQgYHRvdGFsX3Rva2Vuc2AgZ3JlYXRlciB0aGFuIDUwMDBcbiAgICAgKiBjb25zdCBjaGFpblJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2FuZChlcShydW5fdHlwZSwgXCJjaGFpblwiKSwgZ3QobGF0ZW5jeSwgMTApLCBndCh0b3RhbF90b2tlbnMsIDUwMDApKScsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgY2FsbGVkIFwiZXh0cmFjdG9yXCIgd2hvc2Ugcm9vdCBvZiB0aGUgdHJhY2Ugd2FzIGFzc2lnbmVkIGZlZWRiYWNrIFwidXNlcl9zY29yZVwiIHNjb3JlIG9mIDFcbiAgICAgKiBjb25zdCBnb29kRXh0cmFjdG9yUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnZXEobmFtZSwgXCJleHRyYWN0b3JcIiknLFxuICAgICAqICAgdHJhY2VGaWx0ZXI6ICdhbmQoZXEoZmVlZGJhY2tfa2V5LCBcInVzZXJfc2NvcmVcIiksIGVxKGZlZWRiYWNrX3Njb3JlLCAxKSknLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIHRoYXQgc3RhcnRlZCBhZnRlciBhIHNwZWNpZmljIHRpbWVzdGFtcCBhbmQgZWl0aGVyIGhhdmUgXCJlcnJvclwiIG5vdCBlcXVhbCB0byBudWxsIG9yIGEgXCJDb3JyZWN0bmVzc1wiIGZlZWRiYWNrIHNjb3JlIGVxdWFsIHRvIDBcbiAgICAgKiBjb25zdCBjb21wbGV4UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKGd0KHN0YXJ0X3RpbWUsIFwiMjAyMy0wNy0xNVQxMjozNDo1NlpcIiksIG9yKG5lcShlcnJvciwgbnVsbCksIGFuZChlcShmZWVkYmFja19rZXksIFwiQ29ycmVjdG5lc3NcIiksIGVxKGZlZWRiYWNrX3Njb3JlLCAwLjApKSkpJyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyB3aGVyZSBgdGFnc2AgaW5jbHVkZSBcImV4cGVyaW1lbnRhbFwiIG9yIFwiYmV0YVwiIGFuZCBgbGF0ZW5jeWAgaXMgZ3JlYXRlciB0aGFuIDIgc2Vjb25kc1xuICAgICAqIGNvbnN0IHRhZ2dlZFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2FuZChvcihoYXModGFncywgXCJleHBlcmltZW50YWxcIiksIGhhcyh0YWdzLCBcImJldGFcIikpLCBndChsYXRlbmN5LCAyKSknLFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGFzeW5jICpsaXN0UnVucyhwcm9wcykge1xuICAgICAgICBjb25zdCB7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIHBhcmVudFJ1bklkLCB0cmFjZUlkLCByZWZlcmVuY2VFeGFtcGxlSWQsIHN0YXJ0VGltZSwgZXhlY3V0aW9uT3JkZXIsIHJ1blR5cGUsIGVycm9yLCBpZCwgcXVlcnksIGZpbHRlciwgdHJhY2VGaWx0ZXIsIHRyZWVGaWx0ZXIsIGxpbWl0LCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBwcm9qZWN0SWRzID0gW107XG4gICAgICAgIGlmIChwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZHMgPSBBcnJheS5pc0FycmF5KHByb2plY3RJZCkgPyBwcm9qZWN0SWQgOiBbcHJvamVjdElkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3ROYW1lcyA9IEFycmF5LmlzQXJyYXkocHJvamVjdE5hbWUpXG4gICAgICAgICAgICAgICAgPyBwcm9qZWN0TmFtZVxuICAgICAgICAgICAgICAgIDogW3Byb2plY3ROYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RJZHNfID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvamVjdE5hbWVzLm1hcCgobmFtZSkgPT4gdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lOiBuYW1lIH0pLnRoZW4oKHByb2plY3QpID0+IHByb2plY3QuaWQpKSk7XG4gICAgICAgICAgICBwcm9qZWN0SWRzLnB1c2goLi4ucHJvamVjdElkc18pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBzZXNzaW9uOiBwcm9qZWN0SWRzLmxlbmd0aCA/IHByb2plY3RJZHMgOiBudWxsLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1blR5cGUsXG4gICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZTogcmVmZXJlbmNlRXhhbXBsZUlkLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICB0cmFjZV9maWx0ZXI6IHRyYWNlRmlsdGVyLFxuICAgICAgICAgICAgdHJlZV9maWx0ZXI6IHRyZWVGaWx0ZXIsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbk9yZGVyLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUgPyBzdGFydFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICB0cmFjZTogdHJhY2VJZCxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBydW5zIG9mIHRoaXMuX2dldEN1cnNvclBhZ2luYXRlZExpc3QoXCIvcnVucy9xdWVyeVwiLCBib2R5KSkge1xuICAgICAgICAgICAgeWllbGQqIHJ1bnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2hhcmVSdW4ocnVuSWQsIHsgc2hhcmVJZCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVJZCB8fCB1dWlkLnY0KCksXG4gICAgICAgIH07XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gc2VydmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlUnVuKHJ1bklkKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1bnNoYXJlIHJ1blwiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1blNoYXJlZExpbmsocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyBsaXN0U2hhcmVkUnVucyhzaGFyZVRva2VuLCB7IHJ1bklkcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChydW5JZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW5JZCBvZiBydW5JZHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJpZFwiLCBydW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChzaGFyZVRva2VuKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vcnVucyR7cXVlcnlQYXJhbXN9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBydW5zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcnVucztcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXRTaGFyZWRTY2hlbWEoZGF0YXNldElkLCBkYXRhc2V0TmFtZSkge1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVpdGhlciBkYXRhc2V0SWQgb3IgZGF0YXNldE5hbWUgbXVzdCBiZSBnaXZlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNoYXJlU2NoZW1hID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzaGFyZVNjaGVtYS51cmwgPSBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7c2hhcmVTY2hlbWEuc2hhcmVfdG9rZW59L2RgO1xuICAgICAgICByZXR1cm4gc2hhcmVTY2hlbWE7XG4gICAgfVxuICAgIGFzeW5jIHNoYXJlRGF0YXNldChkYXRhc2V0SWQsIGRhdGFzZXROYW1lKSB7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGRhdGFzZXRJZCBvciBkYXRhc2V0TmFtZSBtdXN0IGJlIGdpdmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkLFxuICAgICAgICB9O1xuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaGFyZVNjaGVtYSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2hhcmVTY2hlbWEudXJsID0gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3NoYXJlU2NoZW1hLnNoYXJlX3Rva2VufS9kYDtcbiAgICAgICAgcmV0dXJuIHNoYXJlU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlRGF0YXNldChkYXRhc2V0SWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVuc2hhcmUgZGF0YXNldFwiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFNoYXJlZERhdGFzZXQoc2hhcmVUb2tlbikge1xuICAgICAgICBhc3NlcnRVdWlkKHNoYXJlVG9rZW4pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9wdWJsaWMvJHtzaGFyZVRva2VufS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVByb2plY3QoeyBwcm9qZWN0TmFtZSwgZGVzY3JpcHRpb24gPSBudWxsLCBtZXRhZGF0YSA9IG51bGwsIHVwc2VydCA9IGZhbHNlLCBwcm9qZWN0RXh0cmEgPSBudWxsLCByZWZlcmVuY2VEYXRhc2V0SWQgPSBudWxsLCB9KSB7XG4gICAgICAgIGNvbnN0IHVwc2VydF8gPSB1cHNlcnQgPyBgP3Vwc2VydD10cnVlYCA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5hcGlVcmx9L3Nlc3Npb25zJHt1cHNlcnRffWA7XG4gICAgICAgIGNvbnN0IGV4dHJhID0gcHJvamVjdEV4dHJhIHx8IHt9O1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGV4dHJhW1wibWV0YWRhdGFcIl0gPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVmZXJlbmNlRGF0YXNldElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBib2R5W1wicmVmZXJlbmNlX2RhdGFzZXRfaWRcIl0gPSByZWZlcmVuY2VEYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHNlc3Npb24gJHtwcm9qZWN0TmFtZX06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvamVjdChwcm9qZWN0SWQsIHsgbmFtZSA9IG51bGwsIGRlc2NyaXB0aW9uID0gbnVsbCwgbWV0YWRhdGEgPSBudWxsLCBwcm9qZWN0RXh0cmEgPSBudWxsLCBlbmRUaW1lID0gbnVsbCwgfSkge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZH1gO1xuICAgICAgICBsZXQgZXh0cmEgPSBwcm9qZWN0RXh0cmE7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgZXh0cmEgPSB7IC4uLihleHRyYSB8fCB7fSksIG1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUgPyBuZXcgRGF0ZShlbmRUaW1lKS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBwcm9qZWN0ICR7cHJvamVjdElkfTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBoYXNQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgfSkge1xuICAgICAgICAvLyBUT0RPOiBBZGQgYSBoZWFkIHJlcXVlc3RcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cGFyYW1zfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIC8vIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQncyBPSyBhbmQgd2UncmUgcXVlcnlpbmcgYnkgbmFtZSwgbmVlZCB0byBjaGVjayB0aGUgbGlzdCBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9qZWN0SWQgcXVlcnlpbmdcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVhZFByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBpbmNsdWRlU3RhdHMsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVTdGF0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5jbHVkZV9zdGF0c1wiLCBpbmNsdWRlU3RhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9qZWN0W2lkPSR7cHJvamVjdElkfSwgbmFtZT0ke3Byb2plY3ROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRUZW5hbnRJZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RlbmFudElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgbGltaXQ6IFwiMVwiIH0pO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbmFudElkID0gcHJvamVjdHNbMF0udGVuYW50X2lkO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3RzWzBdLnRlbmFudF9pZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9qZWN0cyBmb3VuZCB0byByZXNvbHZlIHRlbmFudC5cIik7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0UHJvamVjdHMoeyBwcm9qZWN0SWRzLCBuYW1lLCBuYW1lQ29udGFpbnMsIHJlZmVyZW5jZURhdGFzZXRJZCwgcmVmZXJlbmNlRGF0YXNldE5hbWUsIHJlZmVyZW5jZUZyZWUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvamVjdElkIG9mIHByb2plY3RJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgcHJvamVjdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZUNvbnRhaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIG5hbWVDb250YWlucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZURhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgcmVmZXJlbmNlRGF0YXNldElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWZlcmVuY2VEYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7XG4gICAgICAgICAgICAgICAgZGF0YXNldE5hbWU6IHJlZmVyZW5jZURhdGFzZXROYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgZGF0YXNldC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZUZyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlZmVyZW5jZV9mcmVlXCIsIHJlZmVyZW5jZUZyZWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9qZWN0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvc2Vzc2lvbnNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHByb2plY3RzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwcm9qZWN0SWRfO1xuICAgICAgICBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSBwcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWRfKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMvJHtwcm9qZWN0SWRffWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBkZWxldGUgc2Vzc2lvbiAke3Byb2plY3RJZF99ICgke3Byb2plY3ROYW1lfSlgKTtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkQ3N2KHsgY3N2RmlsZSwgZmlsZU5hbWUsIGlucHV0S2V5cywgb3V0cHV0S2V5cywgZGVzY3JpcHRpb24sIGRhdGFUeXBlLCBuYW1lLCB9KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy91cGxvYWRgO1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGNzdkZpbGUsIGZpbGVOYW1lKTtcbiAgICAgICAgaW5wdXRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiaW5wdXRfa2V5c1wiLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm91dHB1dF9rZXlzXCIsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRhdGFfdHlwZVwiLCBkYXRhVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kZXRhaWwgJiYgcmVzdWx0LmRldGFpbC5pbmNsdWRlcyhcImFscmVhZHkgZXhpc3RzXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0ICR7ZmlsZU5hbWV9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgQ1NWOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRGF0YXNldChuYW1lLCB7IGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkYXRhVHlwZSkge1xuICAgICAgICAgICAgYm9keS5kYXRhX3R5cGUgPSBkYXRhVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRldGFpbCAmJiByZXN1bHQuZGV0YWlsLmluY2x1ZGVzKFwiYWxyZWFkeSBleGlzdHNcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFzZXQgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGRhdGFzZXQgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIC8vIGxpbWl0IHRvIDEgcmVzdWx0XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBsaW1pdDogXCIxXCIgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0W2lkPSR7ZGF0YXNldElkfSwgbmFtZT0ke2RhdGFzZXROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGRpZmZEYXRhc2V0VmVyc2lvbnMoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBmcm9tVmVyc2lvbiwgdG9WZXJzaW9uLCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBmcm9tX3ZlcnNpb246IHR5cGVvZiBmcm9tVmVyc2lvbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gZnJvbVZlcnNpb25cbiAgICAgICAgICAgICAgICA6IGZyb21WZXJzaW9uLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB0b192ZXJzaW9uOiB0eXBlb2YgdG9WZXJzaW9uID09PSBcInN0cmluZ1wiID8gdG9WZXJzaW9uIDogdG9WZXJzaW9uLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChgL2RhdGFzZXRzLyR7ZGF0YXNldElkX30vdmVyc2lvbnMvZGlmZmAsIHVybFBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXRPcGVuYWlGaW5ldHVuaW5nKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBjb25zdCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkID0gKGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KSkuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0UmVzcG9uc2UoYCR7cGF0aH0vJHtkYXRhc2V0SWR9L29wZW5haV9mdGApO1xuICAgICAgICBjb25zdCBkYXRhc2V0VGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRUZXh0XG4gICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgICAgIC5tYXAoKGxpbmUpID0+IEpTT04ucGFyc2UobGluZSkpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3REYXRhc2V0cyh7IGxpbWl0ID0gMTAwLCBvZmZzZXQgPSAwLCBkYXRhc2V0SWRzLCBkYXRhc2V0TmFtZSwgZGF0YXNldE5hbWVDb250YWlucywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGxpbWl0OiBsaW1pdC50b1N0cmluZygpLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRfIG9mIGRhdGFzZXRJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgaWRfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgZGF0YXNldE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0TmFtZUNvbnRhaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIGRhdGFzZXROYW1lQ29udGFpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZGF0YXNldHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKHBhdGgsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBkYXRhc2V0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZWxldGVEYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7ZGF0YXNldElkX31gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUV4YW1wbGUoaW5wdXRzLCBvdXRwdXRzLCB7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGNyZWF0ZWRBdCwgZXhhbXBsZUlkIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVkQXRfID0gY3JlYXRlZEF0IHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBkYXRhc2V0X2lkOiBkYXRhc2V0SWRfLFxuICAgICAgICAgICAgaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IGNyZWF0ZWRBdF8/LnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBpZDogZXhhbXBsZUlkLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9leGFtcGxlc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgZXhhbXBsZTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUV4YW1wbGVzKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRzLCBvdXRwdXRzLCBzb3VyY2VSdW5JZHMsIGV4YW1wbGVJZHMsIGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRFeGFtcGxlcyA9IGlucHV0cy5tYXAoKGlucHV0LCBpZHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkXyxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IGlucHV0LFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IG91dHB1dHMgPyBvdXRwdXRzW2lkeF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaWQ6IGV4YW1wbGVJZHMgPyBleGFtcGxlSWRzW2lkeF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc291cmNlX3J1bl9pZDogc291cmNlUnVuSWRzID8gc291cmNlUnVuSWRzW2lkeF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vZXhhbXBsZXMvYnVsa2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZvcm1hdHRlZEV4YW1wbGVzKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGV4YW1wbGVzOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlTExNRXhhbXBsZShpbnB1dCwgZ2VuZXJhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGFtcGxlKHsgaW5wdXQgfSwgeyBvdXRwdXQ6IGdlbmVyYXRpb24gfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNoYXRFeGFtcGxlKGlucHV0LCBnZW5lcmF0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBmaW5hbElucHV0ID0gaW5wdXQubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNMYW5nQ2hhaW5NZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmaW5hbE91dHB1dCA9IGlzTGFuZ0NoYWluTWVzc2FnZShnZW5lcmF0aW9ucylcbiAgICAgICAgICAgID8gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUoZ2VuZXJhdGlvbnMpXG4gICAgICAgICAgICA6IGdlbmVyYXRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFeGFtcGxlKHsgaW5wdXQ6IGZpbmFsSW5wdXQgfSwgeyBvdXRwdXQ6IGZpbmFsT3V0cHV0IH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZWFkRXhhbXBsZShleGFtcGxlSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9leGFtcGxlcy8ke2V4YW1wbGVJZH1gO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZ2V0KHBhdGgpO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdEV4YW1wbGVzKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgZXhhbXBsZUlkcywgYXNPZiwgaW5saW5lUzNVcmxzLCB9ID0ge30pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF87XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGEgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBkYXRhc2V0OiBkYXRhc2V0SWRfIH0pO1xuICAgICAgICBjb25zdCBkYXRhc2V0X3ZlcnNpb24gPSBhc09mXG4gICAgICAgICAgICA/IHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBhc09mXG4gICAgICAgICAgICAgICAgOiBhc09mPy50b0lTT1N0cmluZygpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRhdGFzZXRfdmVyc2lvbikge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImFzX29mXCIsIGRhdGFzZXRfdmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5saW5lUzNVcmxzXyA9IGlubGluZVMzVXJscyA/PyB0cnVlO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5saW5lX3MzX3VybHNcIiwgaW5saW5lUzNVcmxzXy50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKGV4YW1wbGVJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZF8gb2YgZXhhbXBsZUlkcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZFwiLCBpZF8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZXhhbXBsZXMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2V4YW1wbGVzXCIsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBleGFtcGxlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZWxldGVFeGFtcGxlKGV4YW1wbGVJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGV4YW1wbGVJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2V4YW1wbGVzLyR7ZXhhbXBsZUlkfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgdGhpcy5hcGlVcmwgKyBwYXRoLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSAke3BhdGh9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRXhhbXBsZShleGFtcGxlSWQsIHVwZGF0ZSkge1xuICAgICAgICBhc3NlcnRVdWlkKGV4YW1wbGVJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2V4YW1wbGVzLyR7ZXhhbXBsZUlkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGUpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgZXhhbXBsZSAke2V4YW1wbGVJZH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBldmFsdWF0ZVJ1bihydW4sIGV2YWx1YXRvciwgeyBzb3VyY2VJbmZvLCBsb2FkQ2hpbGRSdW5zLCByZWZlcmVuY2VFeGFtcGxlLCB9ID0geyBsb2FkQ2hpbGRSdW5zOiBmYWxzZSB9KSB7XG4gICAgICAgIGxldCBydW5fO1xuICAgICAgICBpZiAodHlwZW9mIHJ1biA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcnVuXyA9IGF3YWl0IHRoaXMucmVhZFJ1bihydW4sIHsgbG9hZENoaWxkUnVucyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcnVuID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiBydW4pIHtcbiAgICAgICAgICAgIHJ1bl8gPSBydW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcnVuIHR5cGU6ICR7dHlwZW9mIHJ1bn1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuXy5yZWZlcmVuY2VfZXhhbXBsZV9pZCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgcnVuXy5yZWZlcmVuY2VfZXhhbXBsZV9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VFeGFtcGxlID0gYXdhaXQgdGhpcy5yZWFkRXhhbXBsZShydW5fLnJlZmVyZW5jZV9leGFtcGxlX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkYmFja1Jlc3VsdCA9IGF3YWl0IGV2YWx1YXRvci5ldmFsdWF0ZVJ1bihydW5fLCByZWZlcmVuY2VFeGFtcGxlKTtcbiAgICAgICAgbGV0IHNvdXJjZUluZm9fID0gc291cmNlSW5mbyA/PyB7fTtcbiAgICAgICAgaWYgKGZlZWRiYWNrUmVzdWx0LmV2YWx1YXRvckluZm8pIHtcbiAgICAgICAgICAgIHNvdXJjZUluZm9fID0geyAuLi5zb3VyY2VJbmZvXywgLi4uZmVlZGJhY2tSZXN1bHQuZXZhbHVhdG9ySW5mbyB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bklkID0gZmVlZGJhY2tSZXN1bHQudGFyZ2V0UnVuSWQgPz8gcnVuXy5pZDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlRmVlZGJhY2socnVuSWQsIGZlZWRiYWNrUmVzdWx0LmtleSwge1xuICAgICAgICAgICAgc2NvcmU6IGZlZWRiYWNrUmVzdWx0Py5zY29yZSxcbiAgICAgICAgICAgIHZhbHVlOiBmZWVkYmFja1Jlc3VsdD8udmFsdWUsXG4gICAgICAgICAgICBjb21tZW50OiBmZWVkYmFja1Jlc3VsdD8uY29tbWVudCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IGZlZWRiYWNrUmVzdWx0Py5jb3JyZWN0aW9uLFxuICAgICAgICAgICAgc291cmNlSW5mbzogc291cmNlSW5mb18sXG4gICAgICAgICAgICBmZWVkYmFja1NvdXJjZVR5cGU6IFwibW9kZWxcIixcbiAgICAgICAgICAgIHNvdXJjZVJ1bklkOiBmZWVkYmFja1Jlc3VsdD8uc291cmNlUnVuSWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVGZWVkYmFjayhydW5JZCwga2V5LCB7IHNjb3JlLCB2YWx1ZSwgY29ycmVjdGlvbiwgY29tbWVudCwgc291cmNlSW5mbywgZmVlZGJhY2tTb3VyY2VUeXBlID0gXCJhcGlcIiwgc291cmNlUnVuSWQsIGZlZWRiYWNrSWQsIGZlZWRiYWNrQ29uZmlnLCB9KSB7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrX3NvdXJjZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGZlZWRiYWNrU291cmNlVHlwZSA/PyBcImFwaVwiLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHNvdXJjZUluZm8gPz8ge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzb3VyY2VSdW5JZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U/Lm1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXSkge1xuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0gPSB7IHJ1bl9pZDogc291cmNlUnVuSWQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tfc291cmNlPy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXT8ucnVuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0ucnVuX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkYmFjayA9IHtcbiAgICAgICAgICAgIGlkOiBmZWVkYmFja0lkID8/IHV1aWQudjQoKSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzY29yZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY29ycmVjdGlvbixcbiAgICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U6IGZlZWRiYWNrX3NvdXJjZSxcbiAgICAgICAgICAgIGZlZWRiYWNrQ29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0vZmVlZGJhY2tgO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZmVlZGJhY2spLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgZmVlZGJhY2tcIik7XG4gICAgICAgIHJldHVybiBmZWVkYmFjaztcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRmVlZGJhY2soZmVlZGJhY2tJZCwgeyBzY29yZSwgdmFsdWUsIGNvcnJlY3Rpb24sIGNvbW1lbnQsIH0pIHtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tVcGRhdGUgPSB7fTtcbiAgICAgICAgaWYgKHNjb3JlICE9PSB1bmRlZmluZWQgJiYgc2NvcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wic2NvcmVcIl0gPSBzY29yZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJ2YWx1ZVwiXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3JyZWN0aW9uICE9PSB1bmRlZmluZWQgJiYgY29ycmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJjb3JyZWN0aW9uXCJdID0gY29ycmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkICYmIGNvbW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wiY29tbWVudFwiXSA9IGNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChmZWVkYmFja0lkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vZmVlZGJhY2svJHtmZWVkYmFja0lkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmZWVkYmFja1VwZGF0ZSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBmZWVkYmFja1wiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZEZlZWRiYWNrKGZlZWRiYWNrSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChmZWVkYmFja0lkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZmVlZGJhY2svJHtmZWVkYmFja0lkfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0KHBhdGgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUZlZWRiYWNrKGZlZWRiYWNrSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChmZWVkYmFja0lkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZmVlZGJhY2svJHtmZWVkYmFja0lkfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgdGhpcy5hcGlVcmwgKyBwYXRoLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSAke3BhdGh9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RGZWVkYmFjayh7IHJ1bklkcywgZmVlZGJhY2tLZXlzLCBmZWVkYmFja1NvdXJjZVR5cGVzLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChydW5JZHMpIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcInJ1blwiLCBydW5JZHMuam9pbihcIixcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZWVkYmFja0tleXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGZlZWRiYWNrS2V5cykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcImtleVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmZWVkYmFja1NvdXJjZVR5cGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgZmVlZGJhY2tTb3VyY2VUeXBlcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcInNvdXJjZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGZlZWRiYWNrcyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvZmVlZGJhY2tcIiwgcXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZmVlZGJhY2tzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwcmVzaWduZWQgZmVlZGJhY2sgdG9rZW4gYW5kIFVSTC5cbiAgICAgKlxuICAgICAqIFRoZSB0b2tlbiBjYW4gYmUgdXNlZCB0byBhdXRob3JpemUgZmVlZGJhY2sgbWV0cmljcyB3aXRob3V0XG4gICAgICogbmVlZGluZyBhbiBBUEkga2V5LiBUaGlzIGlzIHVzZWZ1bCBmb3IgZ2l2aW5nIGJyb3dzZXItYmFzZWRcbiAgICAgKiBhcHBsaWNhdGlvbnMgdGhlIGFiaWxpdHkgdG8gc3VibWl0IGZlZWRiYWNrIHdpdGhvdXQgbmVlZGluZ1xuICAgICAqIHRvIGV4cG9zZSBhbiBBUEkga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJ1bklkIC0gVGhlIElEIG9mIHRoZSBydW4uXG4gICAgICogQHBhcmFtIGZlZWRiYWNrS2V5IC0gVGhlIGZlZWRiYWNrIGtleS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmV4cGlyYXRpb24gLSBUaGUgZXhwaXJhdGlvbiB0aW1lIGZvciB0aGUgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEZlZWRiYWNrSW5nZXN0VG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUHJlc2lnbmVkRmVlZGJhY2tUb2tlbihydW5JZCwgZmVlZGJhY2tLZXksIHsgZXhwaXJhdGlvbiwgZmVlZGJhY2tDb25maWcsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgIGZlZWRiYWNrX2tleTogZmVlZGJhY2tLZXksXG4gICAgICAgICAgICBmZWVkYmFja19jb25maWc6IGZlZWRiYWNrQ29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXhwaXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBpcmF0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYm9keVtcImV4cGlyZXNfYXRcIl0gPSBleHBpcmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhwaXJhdGlvbj8uaG91cnMgfHwgZXhwaXJhdGlvbj8ubWludXRlcyB8fCBleHBpcmF0aW9uPy5kYXlzKSB7XG4gICAgICAgICAgICAgICAgYm9keVtcImV4cGlyZXNfaW5cIl0gPSBleHBpcmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keVtcImV4cGlyZXNfaW5cIl0gPSB7XG4gICAgICAgICAgICAgICAgaG91cnM6IDMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrL3Rva2Vuc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgcHJlc2lnbmVkIGZlZWRiYWNrIHRva2VucyBmb3IgYSBnaXZlbiBydW4gSUQuXG4gICAgICogQHBhcmFtIHJ1bklkIFRoZSBJRCBvZiB0aGUgcnVuLlxuICAgICAqIEByZXR1cm5zIEFuIGFzeW5jIGl0ZXJhYmxlIG9mIEZlZWRiYWNrSW5nZXN0VG9rZW4gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBhc3luYyAqbGlzdFByZXNpZ25lZEZlZWRiYWNrVG9rZW5zKHJ1bklkKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgcnVuX2lkOiBydW5JZCB9KTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB0b2tlbnMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2ZlZWRiYWNrL3Rva2Vuc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogdG9rZW5zO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInV1aWQiLCJBc3luY0NhbGxlciIsImNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlIiwiaXNMYW5nQ2hhaW5NZXNzYWdlIiwiZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSIsImdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSIsImdldFJ1bnRpbWVFbnZpcm9ubWVudCIsIl9fdmVyc2lvbl9fIiwibWVyZ2VSdW50aW1lRW52SW50b1J1bkNyZWF0ZXMiLCJydW5zIiwicnVudGltZUVudiIsImVudlZhcnMiLCJtYXAiLCJydW4iLCJleHRyYSIsIm1ldGFkYXRhIiwicnVudGltZSIsInJldmlzaW9uX2lkIiwiZ2V0VHJhY2luZ1NhbXBsaW5nUmF0ZSIsInNhbXBsaW5nUmF0ZVN0ciIsInVuZGVmaW5lZCIsInNhbXBsaW5nUmF0ZSIsInBhcnNlRmxvYXQiLCJFcnJvciIsImlzTG9jYWxob3N0IiwidXJsIiwic3RyaXBwZWRVcmwiLCJyZXBsYWNlIiwiaG9zdG5hbWUiLCJzcGxpdCIsInJhaXNlRm9yU3RhdHVzIiwicmVzcG9uc2UiLCJvcGVyYXRpb24iLCJib2R5IiwidGV4dCIsIm9rIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsInRvQXJyYXkiLCJpdGVyYWJsZSIsInJlc3VsdCIsIml0ZW0iLCJwdXNoIiwidHJpbVF1b3RlcyIsInN0ciIsInRyaW0iLCJhc3NlcnRVdWlkIiwidmFsaWRhdGUiLCJoYW5kbGU0MjkiLCJyZXRyeUFmdGVyIiwicGFyc2VJbnQiLCJoZWFkZXJzIiwiZ2V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiUXVldWUiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJzaXplIiwiaXRlbXMiLCJsZW5ndGgiLCJwb3AiLCJ1cFRvTiIsInBvcHBlZCIsInNoaWZ0IiwiaXQiLCJmb3JFYWNoIiwiREVGQVVMVF9CQVRDSF9TSVpFX0xJTUlUX0JZVEVTIiwiQ2xpZW50IiwiY29uZmlnIiwiU2V0IiwiZGVmYXVsdENvbmZpZyIsImdldERlZmF1bHRDbGllbnRDb25maWciLCJ0cmFjaW5nU2FtcGxlUmF0ZSIsImFwaVVybCIsImFwaUtleSIsIndlYlVybCIsInRpbWVvdXRfbXMiLCJjYWxsZXIiLCJjYWxsZXJPcHRpb25zIiwiYmF0Y2hJbmdlc3RDYWxsZXIiLCJvbkZhaWxlZFJlc3BvbnNlSG9vayIsImhpZGVJbnB1dHMiLCJoaWRlT3V0cHV0cyIsImF1dG9CYXRjaFRyYWNpbmciLCJwZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdCIsImdldEhvc3RVcmwiLCJpbmNsdWRlcyIsImVuZHNXaXRoIiwicHJvY2Vzc0lucHV0cyIsImlucHV0cyIsInByb2Nlc3NPdXRwdXRzIiwib3V0cHV0cyIsInByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyIsInJ1blBhcmFtcyIsIl9nZXRSZXNwb25zZSIsInBhdGgiLCJxdWVyeVBhcmFtcyIsInBhcmFtc1N0cmluZyIsInRvU3RyaW5nIiwiY2FsbCIsImZldGNoIiwibWV0aG9kIiwic2lnbmFsIiwiQWJvcnRTaWduYWwiLCJ0aW1lb3V0IiwiX2dldCIsImpzb24iLCJfZ2V0UGFnaW5hdGVkIiwiVVJMU2VhcmNoUGFyYW1zIiwib2Zmc2V0IiwiTnVtYmVyIiwibGltaXQiLCJzZXQiLCJTdHJpbmciLCJfZ2V0Q3Vyc29yUGFnaW5hdGVkTGlzdCIsInJlcXVlc3RNZXRob2QiLCJkYXRhS2V5IiwiYm9keVBhcmFtcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXNwb25zZUJvZHkiLCJjdXJzb3JzIiwibmV4dCIsImN1cnNvciIsIl9maWx0ZXJGb3JTYW1wbGluZyIsInBhdGNoIiwic2FtcGxlZCIsInNhbXBsZWRQb3N0VXVpZHMiLCJoYXMiLCJpZCIsImRlbGV0ZSIsIk1hdGgiLCJyYW5kb20iLCJhZGQiLCJkcmFpbkF1dG9CYXRjaFF1ZXVlIiwiYXV0b0JhdGNoUXVldWUiLCJiYXRjaCIsImRvbmUiLCJiYXRjaEluZ2VzdFJ1bnMiLCJydW5DcmVhdGVzIiwiZmlsdGVyIiwiYWN0aW9uIiwicnVuVXBkYXRlcyIsInByb2Nlc3NSdW5PcGVyYXRpb24iLCJpbW1lZGlhdGVseVRyaWdnZXJCYXRjaCIsIm9sZFRpbWVvdXQiLCJhdXRvQmF0Y2hUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiaXRlbVByb21pc2UiLCJjYXRjaCIsImNvbnNvbGUiLCJlcnJvciIsImF1dG9CYXRjaEFnZ3JlZ2F0aW9uRGVsYXlNcyIsImF1dG9CYXRjaEluaXRpYWxEZWxheU1zIiwiX2dldFNlcnZlckluZm8iLCJBY2NlcHQiLCJiYXRjaEVuZHBvaW50SXNTdXBwb3J0ZWQiLCJzZXJ2ZXJJbmZvIiwiZSIsImNyZWF0ZVJ1biIsInNlc3Npb25fbmFtZSIsInByb2plY3RfbmFtZSIsInJ1bkNyZWF0ZSIsInN0YXJ0X3RpbWUiLCJEYXRlIiwibm93IiwidHJhY2VfaWQiLCJkb3R0ZWRfb3JkZXIiLCJtZXJnZWRSdW5DcmVhdGVQYXJhbXMiLCJwcmVwYXJlZENyZWF0ZVBhcmFtcyIsImNyZWF0ZSIsInByZXBhcmVkVXBkYXRlUGFyYW1zIiwidXBkYXRlIiwiY3JlYXRlQnlJZCIsInJlZHVjZSIsInBhcmFtcyIsInN0YW5kYWxvbmVVcGRhdGVzIiwidXBkYXRlUGFyYW0iLCJ2YWx1ZXMiLCJyYXdCYXRjaCIsInBvc3QiLCJiYXRjaEVuZHBvaW50U3VwcG9ydGVkIiwicHJlcGFyZWRDcmVhdGVQYXJhbSIsInByZXBhcmVkVXBkYXRlUGFyYW0iLCJ1cGRhdGVSdW4iLCJzaXplTGltaXRCeXRlcyIsImJhdGNoX2luZ2VzdF9jb25maWciLCJzaXplX2xpbWl0X2J5dGVzIiwiYmF0Y2hDaHVua3MiLCJjdXJyZW50QmF0Y2hTaXplQnl0ZXMiLCJrIiwia2V5IiwiYmF0Y2hJdGVtcyIsInJldmVyc2UiLCJiYXRjaEl0ZW0iLCJzdHJpbmdpZmllZEJhdGNoSXRlbSIsIl9wb3N0QmF0Y2hJbmdlc3RSdW5zIiwicnVuSWQiLCJkYXRhIiwiZW5kX3RpbWUiLCJwYXJlbnRfcnVuX2lkIiwicmVhZFJ1biIsImxvYWRDaGlsZFJ1bnMiLCJjaGlsZF9ydW5faWRzIiwiX2xvYWRDaGlsZFJ1bnMiLCJnZXRSdW5VcmwiLCJwcm9qZWN0T3B0cyIsInNlc3Npb25JZCIsInNlc3Npb25faWQiLCJwcm9qZWN0TmFtZSIsInJlYWRQcm9qZWN0IiwicHJvamVjdElkIiwicHJvamVjdCIsInRlbmFudElkIiwiX2dldFRlbmFudElkIiwicnVuXyIsImFwcF9wYXRoIiwiYmFzZVVybCIsImNoaWxkUnVucyIsImxpc3RSdW5zIiwidHJlZW1hcCIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJjaGlsZFJ1biIsImNoaWxkX3J1bnMiLCJwcm9wcyIsInBhcmVudFJ1bklkIiwidHJhY2VJZCIsInJlZmVyZW5jZUV4YW1wbGVJZCIsInN0YXJ0VGltZSIsImV4ZWN1dGlvbk9yZGVyIiwicnVuVHlwZSIsInF1ZXJ5IiwidHJhY2VGaWx0ZXIiLCJ0cmVlRmlsdGVyIiwicHJvamVjdElkcyIsIkFycmF5IiwiaXNBcnJheSIsInByb2plY3ROYW1lcyIsInByb2plY3RJZHNfIiwiYWxsIiwibmFtZSIsInRoZW4iLCJzZXNzaW9uIiwicnVuX3R5cGUiLCJyZWZlcmVuY2VfZXhhbXBsZSIsInRyYWNlX2ZpbHRlciIsInRyZWVfZmlsdGVyIiwiZXhlY3V0aW9uX29yZGVyIiwicGFyZW50X3J1biIsInRvSVNPU3RyaW5nIiwidHJhY2UiLCJzaGFyZVJ1biIsInNoYXJlSWQiLCJydW5faWQiLCJzaGFyZV90b2tlbiIsInY0IiwidW5zaGFyZVJ1biIsInJlYWRSdW5TaGFyZWRMaW5rIiwibGlzdFNoYXJlZFJ1bnMiLCJzaGFyZVRva2VuIiwicnVuSWRzIiwiYXBwZW5kIiwicmVhZERhdGFzZXRTaGFyZWRTY2hlbWEiLCJkYXRhc2V0SWQiLCJkYXRhc2V0TmFtZSIsImRhdGFzZXQiLCJyZWFkRGF0YXNldCIsInNoYXJlU2NoZW1hIiwic2hhcmVEYXRhc2V0IiwiZGF0YXNldF9pZCIsInVuc2hhcmVEYXRhc2V0IiwicmVhZFNoYXJlZERhdGFzZXQiLCJjcmVhdGVQcm9qZWN0IiwiZGVzY3JpcHRpb24iLCJ1cHNlcnQiLCJwcm9qZWN0RXh0cmEiLCJyZWZlcmVuY2VEYXRhc2V0SWQiLCJ1cHNlcnRfIiwiZW5kcG9pbnQiLCJ1cGRhdGVQcm9qZWN0IiwiZW5kVGltZSIsImhhc1Byb2plY3QiLCJpbmNsdWRlU3RhdHMiLCJfdGVuYW50SWQiLCJwcm9qZWN0cyIsInRlbmFudF9pZCIsImxpc3RQcm9qZWN0cyIsIm5hbWVDb250YWlucyIsInJlZmVyZW5jZURhdGFzZXROYW1lIiwicmVmZXJlbmNlRnJlZSIsImRlbGV0ZVByb2plY3QiLCJwcm9qZWN0SWRfIiwidXBsb2FkQ3N2IiwiY3N2RmlsZSIsImZpbGVOYW1lIiwiaW5wdXRLZXlzIiwib3V0cHV0S2V5cyIsImRhdGFUeXBlIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImRldGFpbCIsImNyZWF0ZURhdGFzZXQiLCJkYXRhX3R5cGUiLCJkaWZmRGF0YXNldFZlcnNpb25zIiwiZnJvbVZlcnNpb24iLCJ0b1ZlcnNpb24iLCJkYXRhc2V0SWRfIiwidXJsUGFyYW1zIiwiZnJvbV92ZXJzaW9uIiwidG9fdmVyc2lvbiIsInJlYWREYXRhc2V0T3BlbmFpRmluZXR1bmluZyIsImRhdGFzZXRUZXh0IiwibGluZSIsInBhcnNlIiwibGlzdERhdGFzZXRzIiwiZGF0YXNldElkcyIsImRhdGFzZXROYW1lQ29udGFpbnMiLCJpZF8iLCJkYXRhc2V0cyIsImRlbGV0ZURhdGFzZXQiLCJjcmVhdGVFeGFtcGxlIiwiY3JlYXRlZEF0IiwiZXhhbXBsZUlkIiwiY3JlYXRlZEF0XyIsImNyZWF0ZWRfYXQiLCJjcmVhdGVFeGFtcGxlcyIsInNvdXJjZVJ1bklkcyIsImV4YW1wbGVJZHMiLCJmb3JtYXR0ZWRFeGFtcGxlcyIsImlucHV0IiwiaWR4Iiwic291cmNlX3J1bl9pZCIsImNyZWF0ZUxMTUV4YW1wbGUiLCJnZW5lcmF0aW9uIiwib3B0aW9ucyIsIm91dHB1dCIsImNyZWF0ZUNoYXRFeGFtcGxlIiwiZ2VuZXJhdGlvbnMiLCJmaW5hbElucHV0IiwibWVzc2FnZSIsImZpbmFsT3V0cHV0IiwicmVhZEV4YW1wbGUiLCJsaXN0RXhhbXBsZXMiLCJhc09mIiwiaW5saW5lUzNVcmxzIiwiZGF0YXNldF92ZXJzaW9uIiwiaW5saW5lUzNVcmxzXyIsImV4YW1wbGVzIiwiZGVsZXRlRXhhbXBsZSIsInVwZGF0ZUV4YW1wbGUiLCJldmFsdWF0ZVJ1biIsImV2YWx1YXRvciIsInNvdXJjZUluZm8iLCJyZWZlcmVuY2VFeGFtcGxlIiwicmVmZXJlbmNlX2V4YW1wbGVfaWQiLCJmZWVkYmFja1Jlc3VsdCIsInNvdXJjZUluZm9fIiwiZXZhbHVhdG9ySW5mbyIsInRhcmdldFJ1bklkIiwiY3JlYXRlRmVlZGJhY2siLCJzY29yZSIsImNvbW1lbnQiLCJjb3JyZWN0aW9uIiwiZmVlZGJhY2tTb3VyY2VUeXBlIiwic291cmNlUnVuSWQiLCJmZWVkYmFja0lkIiwiZmVlZGJhY2tDb25maWciLCJmZWVkYmFja19zb3VyY2UiLCJ0eXBlIiwiZmVlZGJhY2siLCJ1cGRhdGVGZWVkYmFjayIsImZlZWRiYWNrVXBkYXRlIiwicmVhZEZlZWRiYWNrIiwiZGVsZXRlRmVlZGJhY2siLCJsaXN0RmVlZGJhY2siLCJmZWVkYmFja0tleXMiLCJmZWVkYmFja1NvdXJjZVR5cGVzIiwiam9pbiIsImZlZWRiYWNrcyIsImNyZWF0ZVByZXNpZ25lZEZlZWRiYWNrVG9rZW4iLCJmZWVkYmFja0tleSIsImV4cGlyYXRpb24iLCJmZWVkYmFja19rZXkiLCJmZWVkYmFja19jb25maWciLCJob3VycyIsIm1pbnV0ZXMiLCJkYXlzIiwibGlzdFByZXNpZ25lZEZlZWRiYWNrVG9rZW5zIiwidG9rZW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/langsmith/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _run_trees_js__WEBPACK_IMPORTED_MODULE_1__.RunTree),\n/* harmony export */   __version__: () => (/* binding */ __version__)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n\n\n// Update using yarn bump-version\nconst __version__ = \"0.1.13\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUM7QUFDSTtBQUN6QyxpQ0FBaUM7QUFDMUIsTUFBTUUsY0FBYyxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktZm9ybS1idWlsZGVyLXR1dG9yaWFsLy4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L2luZGV4LmpzP2FhMjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQ2xpZW50IH0gZnJvbSBcIi4vY2xpZW50LmpzXCI7XG5leHBvcnQgeyBSdW5UcmVlIH0gZnJvbSBcIi4vcnVuX3RyZWVzLmpzXCI7XG4vLyBVcGRhdGUgdXNpbmcgeWFybiBidW1wLXZlcnNpb25cbmV4cG9ydCBjb25zdCBfX3ZlcnNpb25fXyA9IFwiMC4xLjEzXCI7XG4iXSwibmFtZXMiOlsiQ2xpZW50IiwiUnVuVHJlZSIsIl9fdmVyc2lvbl9fIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/run_trees.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/run_trees.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* binding */ RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* binding */ convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* binding */ isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* binding */ isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n\n\n\nconst warnedMessages = {};\nfunction warnOnce(message) {\n    if (!warnedMessages[message]) {\n        console.warn(message);\n        warnedMessages[message] = true;\n    }\n}\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId) {\n    return stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}000Z`) + runId;\n}\nclass RunTree {\n    constructor(config){\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"run_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"end_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"extra\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"error\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reference_example_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"events\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"dotted_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const defaultConfig = RunTree.getDefaultConfig();\n        const client = config.client ?? new _client_js__WEBPACK_IMPORTED_MODULE_1__.Client();\n        Object.assign(this, {\n            ...defaultConfig,\n            ...config,\n            client\n        });\n        if (!this.trace_id) {\n            if (this.parent_run) {\n                this.trace_id = this.parent_run.trace_id ?? this.id;\n            } else {\n                this.trace_id = this.id;\n            }\n        }\n        if (!this.dotted_order) {\n            const currentDottedOrder = convertToDottedOrderFormat(this.start_time, this.id);\n            if (this.parent_run) {\n                this.dotted_order = this.parent_run.dotted_order + \".\" + currentDottedOrder;\n            } else {\n                this.dotted_order = currentDottedOrder;\n            }\n        }\n    }\n    static fromRunnableConfig(config, props) {\n        // We only handle the callback manager case for now\n        const callbackManager = config?.callbacks;\n        let parentRun;\n        let projectName;\n        if (callbackManager) {\n            const parentRunId = callbackManager?.getParentRunId?.() ?? \"\";\n            const langChainTracer = callbackManager?.handlers?.find((handler)=>handler?.name == \"langchain_tracer\");\n            parentRun = langChainTracer?.getRun?.(parentRunId);\n            projectName = langChainTracer?.projectName;\n        }\n        const deduppedTags = [\n            ...new Set((parentRun?.tags ?? []).concat(config?.tags ?? []))\n        ];\n        const dedupedMetadata = {\n            ...parentRun?.extra?.metadata,\n            ...config?.metadata\n        };\n        const rt = new RunTree({\n            name: props?.name ?? \"<lambda>\",\n            parent_run: parentRun,\n            tags: deduppedTags,\n            extra: {\n                metadata: dedupedMetadata\n            },\n            project_name: projectName\n        });\n        return rt;\n    }\n    static getDefaultConfig() {\n        return {\n            id: uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"](),\n            run_type: \"chain\",\n            project_name: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n            \"default\",\n            child_runs: [],\n            api_url: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n            api_key: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\"),\n            caller_options: {},\n            start_time: Date.now(),\n            serialized: {},\n            inputs: {},\n            extra: {}\n        };\n    }\n    async createChild(config) {\n        const child = new RunTree({\n            ...config,\n            parent_run: this,\n            project_name: this.project_name,\n            client: this.client\n        });\n        this.child_runs.push(child);\n        return child;\n    }\n    async end(outputs, error, endTime = Date.now()) {\n        this.outputs = outputs;\n        this.error = error;\n        this.end_time = endTime;\n    }\n    async _convertToCreate(run, excludeChildRuns = true) {\n        const runExtra = run.extra ?? {};\n        if (!runExtra.runtime) {\n            runExtra.runtime = {};\n        }\n        const runtimeEnv = await (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getRuntimeEnvironment)();\n        for (const [k, v] of Object.entries(runtimeEnv)){\n            if (!runExtra.runtime[k]) {\n                runExtra.runtime[k] = v;\n            }\n        }\n        let child_runs;\n        let parent_run_id;\n        if (!excludeChildRuns) {\n            child_runs = await Promise.all(run.child_runs.map((child_run)=>this._convertToCreate(child_run, excludeChildRuns)));\n            parent_run_id = undefined;\n        } else {\n            parent_run_id = run.parent_run?.id;\n            child_runs = [];\n        }\n        const persistedRun = {\n            id: run.id,\n            name: run.name,\n            start_time: run.start_time,\n            end_time: run.end_time,\n            run_type: run.run_type,\n            reference_example_id: run.reference_example_id,\n            extra: runExtra,\n            serialized: run.serialized,\n            error: run.error,\n            inputs: run.inputs,\n            outputs: run.outputs,\n            session_name: run.project_name,\n            child_runs: child_runs,\n            parent_run_id: parent_run_id,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            tags: run.tags\n        };\n        return persistedRun;\n    }\n    async postRun(excludeChildRuns = true) {\n        const runCreate = await this._convertToCreate(this, true);\n        await this.client.createRun(runCreate);\n        if (!excludeChildRuns) {\n            warnOnce(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n            for (const childRun of this.child_runs){\n                await childRun.postRun(false);\n            }\n        }\n    }\n    async patchRun() {\n        const runUpdate = {\n            end_time: this.end_time,\n            error: this.error,\n            outputs: this.outputs,\n            parent_run_id: this.parent_run?.id,\n            reference_example_id: this.reference_example_id,\n            extra: this.extra,\n            events: this.events,\n            dotted_order: this.dotted_order,\n            trace_id: this.trace_id,\n            tags: this.tags\n        };\n        await this.client.updateRun(this.id, runUpdate);\n    }\n}\nfunction isRunTree(x) {\n    return x !== undefined && typeof x.createChild === \"function\" && typeof x.postRun === \"function\";\n}\nfunction containsLangChainTracerLike(x) {\n    return Array.isArray(x) && x.some((callback)=>{\n        return typeof callback.name === \"string\" && callback.name === \"langchain_tracer\";\n    });\n}\nfunction isRunnableConfigLike(x) {\n    // Check that it's an object with a callbacks arg\n    // that has either a CallbackManagerLike object with a langchain tracer within it\n    // or an array with a LangChainTracerLike object within it\n    return x !== undefined && typeof x.callbacks === \"object\" && // Callback manager with a langchain tracer\n    (containsLangChainTracerLike(x.callbacks?.handlers) || // Or it's an array with a LangChainTracerLike object within it\n    containsLangChainTracerLike(x.callbacks));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNkI7QUFDa0Q7QUFDMUM7QUFDckMsTUFBTUksaUJBQWlCLENBQUM7QUFDeEIsU0FBU0MsU0FBU0MsT0FBTztJQUNyQixJQUFJLENBQUNGLGNBQWMsQ0FBQ0UsUUFBUSxFQUFFO1FBQzFCQyxRQUFRQyxJQUFJLENBQUNGO1FBQ2JGLGNBQWMsQ0FBQ0UsUUFBUSxHQUFHO0lBQzlCO0FBQ0o7QUFDQSxTQUFTRyxxQkFBcUJDLEtBQUs7SUFDL0IsT0FBT0EsTUFBTUMsT0FBTyxDQUFDLFVBQVU7QUFDbkM7QUFDTyxTQUFTQywyQkFBMkJDLEtBQUssRUFBRUMsS0FBSztJQUNuRCxPQUFRTCxxQkFBcUIsQ0FBQyxFQUFFLElBQUlNLEtBQUtGLE9BQU9HLFdBQVcsR0FBR0MsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUM1RUg7QUFDUjtBQUNPLE1BQU1JO0lBQ1RDLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQkMsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxNQUFNO1lBQzlCQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxZQUFZO1lBQ3BDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxnQkFBZ0I7WUFDeENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFlBQVk7WUFDcENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFVBQVU7WUFDbENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVc7WUFDbkNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtR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LEVBQUVoRSxTQUFTO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktZm9ybS1idWlsZGVyLXR1dG9yaWFsLy4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3J1bl90cmVlcy5qcz81MTJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV1aWQgZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUsIGdldFJ1bnRpbWVFbnZpcm9ubWVudCB9IGZyb20gXCIuL3V0aWxzL2Vudi5qc1wiO1xuaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcIi4vY2xpZW50LmpzXCI7XG5jb25zdCB3YXJuZWRNZXNzYWdlcyA9IHt9O1xuZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICAgIGlmICghd2FybmVkTWVzc2FnZXNbbWVzc2FnZV0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICB3YXJuZWRNZXNzYWdlc1ttZXNzYWdlXSA9IHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaXBOb25BbHBoYW51bWVyaWMoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvWy06Ll0vZywgXCJcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQoZXBvY2gsIHJ1bklkKSB7XG4gICAgcmV0dXJuIChzdHJpcE5vbkFscGhhbnVtZXJpYyhgJHtuZXcgRGF0ZShlcG9jaCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCAtMSl9MDAwWmApICtcbiAgICAgICAgcnVuSWQpO1xufVxuZXhwb3J0IGNsYXNzIFJ1blRyZWUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bl90eXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3RfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJlbnRfcnVuXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoaWxkX3J1bnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhcnRfdGltZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmRfdGltZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleHRyYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVycm9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcmlhbGl6ZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5wdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm91dHB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmZXJlbmNlX2V4YW1wbGVfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV2ZW50c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjZV9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb3R0ZWRfb3JkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IFJ1blRyZWUuZ2V0RGVmYXVsdENvbmZpZygpO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBjb25maWcuY2xpZW50ID8/IG5ldyBDbGllbnQoKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IC4uLmRlZmF1bHRDb25maWcsIC4uLmNvbmZpZywgY2xpZW50IH0pO1xuICAgICAgICBpZiAoIXRoaXMudHJhY2VfaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudF9ydW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlX2lkID0gdGhpcy5wYXJlbnRfcnVuLnRyYWNlX2lkID8/IHRoaXMuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlX2lkID0gdGhpcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZG90dGVkX29yZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RG90dGVkT3JkZXIgPSBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdCh0aGlzLnN0YXJ0X3RpbWUsIHRoaXMuaWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50X3J1bikge1xuICAgICAgICAgICAgICAgIHRoaXMuZG90dGVkX29yZGVyID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcnVuLmRvdHRlZF9vcmRlciArIFwiLlwiICsgY3VycmVudERvdHRlZE9yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3R0ZWRfb3JkZXIgPSBjdXJyZW50RG90dGVkT3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21SdW5uYWJsZUNvbmZpZyhjb25maWcsIHByb3BzKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgaGFuZGxlIHRoZSBjYWxsYmFjayBtYW5hZ2VyIGNhc2UgZm9yIG5vd1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXIgPSBjb25maWc/LmNhbGxiYWNrcztcbiAgICAgICAgbGV0IHBhcmVudFJ1bjtcbiAgICAgICAgbGV0IHByb2plY3ROYW1lO1xuICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRSdW5JZCA9IGNhbGxiYWNrTWFuYWdlcj8uZ2V0UGFyZW50UnVuSWQ/LigpID8/IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBsYW5nQ2hhaW5UcmFjZXIgPSBjYWxsYmFja01hbmFnZXI/LmhhbmRsZXJzPy5maW5kKChoYW5kbGVyKSA9PiBoYW5kbGVyPy5uYW1lID09IFwibGFuZ2NoYWluX3RyYWNlclwiKTtcbiAgICAgICAgICAgIHBhcmVudFJ1biA9IGxhbmdDaGFpblRyYWNlcj8uZ2V0UnVuPy4ocGFyZW50UnVuSWQpO1xuICAgICAgICAgICAgcHJvamVjdE5hbWUgPSBsYW5nQ2hhaW5UcmFjZXI/LnByb2plY3ROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZHVwcGVkVGFncyA9IFtcbiAgICAgICAgICAgIC4uLm5ldyBTZXQoKHBhcmVudFJ1bj8udGFncyA/PyBbXSkuY29uY2F0KGNvbmZpZz8udGFncyA/PyBbXSkpLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBkZWR1cGVkTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAuLi5wYXJlbnRSdW4/LmV4dHJhPy5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLmNvbmZpZz8ubWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJ0ID0gbmV3IFJ1blRyZWUoe1xuICAgICAgICAgICAgbmFtZTogcHJvcHM/Lm5hbWUgPz8gXCI8bGFtYmRhPlwiLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogcGFyZW50UnVuLFxuICAgICAgICAgICAgdGFnczogZGVkdXBwZWRUYWdzLFxuICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogZGVkdXBlZE1ldGFkYXRhLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q29uZmlnKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHV1aWQudjQoKSxcbiAgICAgICAgICAgIHJ1bl90eXBlOiBcImNoYWluXCIsXG4gICAgICAgICAgICBwcm9qZWN0X25hbWU6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fUFJPSkVDVFwiKSA/P1xuICAgICAgICAgICAgICAgIGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fU0VTU0lPTlwiKSA/PyAvLyBUT0RPOiBEZXByZWNhdGVcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgYXBpX3VybDogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9FTkRQT0lOVFwiKSA/PyBcImh0dHA6Ly9sb2NhbGhvc3Q6MTk4NFwiLFxuICAgICAgICAgICAgYXBpX2tleTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9BUElfS0VZXCIpLFxuICAgICAgICAgICAgY2FsbGVyX29wdGlvbnM6IHt9LFxuICAgICAgICAgICAgc3RhcnRfdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHt9LFxuICAgICAgICAgICAgaW5wdXRzOiB7fSxcbiAgICAgICAgICAgIGV4dHJhOiB7fSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQ2hpbGQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbmV3IFJ1blRyZWUoe1xuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogdGhpcyxcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogdGhpcy5wcm9qZWN0X25hbWUsXG4gICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGlsZF9ydW5zLnB1c2goY2hpbGQpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGFzeW5jIGVuZChvdXRwdXRzLCBlcnJvciwgZW5kVGltZSA9IERhdGUubm93KCkpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmVuZF90aW1lID0gZW5kVGltZTtcbiAgICB9XG4gICAgYXN5bmMgX2NvbnZlcnRUb0NyZWF0ZShydW4sIGV4Y2x1ZGVDaGlsZFJ1bnMgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHJ1bkV4dHJhID0gcnVuLmV4dHJhID8/IHt9O1xuICAgICAgICBpZiAoIXJ1bkV4dHJhLnJ1bnRpbWUpIHtcbiAgICAgICAgICAgIHJ1bkV4dHJhLnJ1bnRpbWUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW50aW1lRW52ID0gYXdhaXQgZ2V0UnVudGltZUVudmlyb25tZW50KCk7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHJ1bnRpbWVFbnYpKSB7XG4gICAgICAgICAgICBpZiAoIXJ1bkV4dHJhLnJ1bnRpbWVba10pIHtcbiAgICAgICAgICAgICAgICBydW5FeHRyYS5ydW50aW1lW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRfcnVucztcbiAgICAgICAgbGV0IHBhcmVudF9ydW5faWQ7XG4gICAgICAgIGlmICghZXhjbHVkZUNoaWxkUnVucykge1xuICAgICAgICAgICAgY2hpbGRfcnVucyA9IGF3YWl0IFByb21pc2UuYWxsKHJ1bi5jaGlsZF9ydW5zLm1hcCgoY2hpbGRfcnVuKSA9PiB0aGlzLl9jb252ZXJ0VG9DcmVhdGUoY2hpbGRfcnVuLCBleGNsdWRlQ2hpbGRSdW5zKSkpO1xuICAgICAgICAgICAgcGFyZW50X3J1bl9pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQgPSBydW4ucGFyZW50X3J1bj8uaWQ7XG4gICAgICAgICAgICBjaGlsZF9ydW5zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVyc2lzdGVkUnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bi5uYW1lLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogcnVuLnN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBlbmRfdGltZTogcnVuLmVuZF90aW1lLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlX2lkOiBydW4ucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICBleHRyYTogcnVuRXh0cmEsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBydW4uc2VyaWFsaXplZCxcbiAgICAgICAgICAgIGVycm9yOiBydW4uZXJyb3IsXG4gICAgICAgICAgICBpbnB1dHM6IHJ1bi5pbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXRzOiBydW4ub3V0cHV0cyxcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZTogcnVuLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IGNoaWxkX3J1bnMsXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRfcnVuX2lkLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IHJ1bi50cmFjZV9pZCxcbiAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogcnVuLmRvdHRlZF9vcmRlcixcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGVyc2lzdGVkUnVuO1xuICAgIH1cbiAgICBhc3luYyBwb3N0UnVuKGV4Y2x1ZGVDaGlsZFJ1bnMgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHJ1bkNyZWF0ZSA9IGF3YWl0IHRoaXMuX2NvbnZlcnRUb0NyZWF0ZSh0aGlzLCB0cnVlKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY3JlYXRlUnVuKHJ1bkNyZWF0ZSk7XG4gICAgICAgIGlmICghZXhjbHVkZUNoaWxkUnVucykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXCJQb3N0aW5nIHdpdGggZXhjbHVkZUNoaWxkUnVucz1mYWxzZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkUnVuIG9mIHRoaXMuY2hpbGRfcnVucykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNoaWxkUnVuLnBvc3RSdW4oZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhdGNoUnVuKCkge1xuICAgICAgICBjb25zdCBydW5VcGRhdGUgPSB7XG4gICAgICAgICAgICBlbmRfdGltZTogdGhpcy5lbmRfdGltZSxcbiAgICAgICAgICAgIGVycm9yOiB0aGlzLmVycm9yLFxuICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogdGhpcy5wYXJlbnRfcnVuPy5pZCxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlX2lkOiB0aGlzLnJlZmVyZW5jZV9leGFtcGxlX2lkLFxuICAgICAgICAgICAgZXh0cmE6IHRoaXMuZXh0cmEsXG4gICAgICAgICAgICBldmVudHM6IHRoaXMuZXZlbnRzLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiB0aGlzLmRvdHRlZF9vcmRlcixcbiAgICAgICAgICAgIHRyYWNlX2lkOiB0aGlzLnRyYWNlX2lkLFxuICAgICAgICAgICAgdGFnczogdGhpcy50YWdzLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC51cGRhdGVSdW4odGhpcy5pZCwgcnVuVXBkYXRlKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSdW5UcmVlKHgpIHtcbiAgICByZXR1cm4gKHggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2YgeC5jcmVhdGVDaGlsZCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiB4LnBvc3RSdW4gPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UoeCkge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh4KSAmJlxuICAgICAgICB4LnNvbWUoKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBjYWxsYmFjay5uYW1lID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgY2FsbGJhY2submFtZSA9PT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpO1xuICAgICAgICB9KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSdW5uYWJsZUNvbmZpZ0xpa2UoeCkge1xuICAgIC8vIENoZWNrIHRoYXQgaXQncyBhbiBvYmplY3Qgd2l0aCBhIGNhbGxiYWNrcyBhcmdcbiAgICAvLyB0aGF0IGhhcyBlaXRoZXIgYSBDYWxsYmFja01hbmFnZXJMaWtlIG9iamVjdCB3aXRoIGEgbGFuZ2NoYWluIHRyYWNlciB3aXRoaW4gaXRcbiAgICAvLyBvciBhbiBhcnJheSB3aXRoIGEgTGFuZ0NoYWluVHJhY2VyTGlrZSBvYmplY3Qgd2l0aGluIGl0XG4gICAgcmV0dXJuICh4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIHguY2FsbGJhY2tzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIC8vIENhbGxiYWNrIG1hbmFnZXIgd2l0aCBhIGxhbmdjaGFpbiB0cmFjZXJcbiAgICAgICAgKGNvbnRhaW5zTGFuZ0NoYWluVHJhY2VyTGlrZSh4LmNhbGxiYWNrcz8uaGFuZGxlcnMpIHx8XG4gICAgICAgICAgICAvLyBPciBpdCdzIGFuIGFycmF5IHdpdGggYSBMYW5nQ2hhaW5UcmFjZXJMaWtlIG9iamVjdCB3aXRoaW4gaXRcbiAgICAgICAgICAgIGNvbnRhaW5zTGFuZ0NoYWluVHJhY2VyTGlrZSh4LmNhbGxiYWNrcykpKTtcbn1cbiJdLCJuYW1lcyI6WyJ1dWlkIiwiZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSIsImdldFJ1bnRpbWVFbnZpcm9ubWVudCIsIkNsaWVudCIsIndhcm5lZE1lc3NhZ2VzIiwid2Fybk9uY2UiLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iLCJzdHJpcE5vbkFscGhhbnVtZXJpYyIsImlucHV0IiwicmVwbGFjZSIsImNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0IiwiZXBvY2giLCJydW5JZCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNsaWNlIiwiUnVuVHJlZSIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsImRlZmF1bHRDb25maWciLCJnZXREZWZhdWx0Q29uZmlnIiwiY2xpZW50IiwiYXNzaWduIiwidHJhY2VfaWQiLCJwYXJlbnRfcnVuIiwiaWQiLCJkb3R0ZWRfb3JkZXIiLCJjdXJyZW50RG90dGVkT3JkZXIiLCJzdGFydF90aW1lIiwiZnJvbVJ1bm5hYmxlQ29uZmlnIiwicHJvcHMiLCJjYWxsYmFja01hbmFnZXIiLCJjYWxsYmFja3MiLCJwYXJlbnRSdW4iLCJwcm9qZWN0TmFtZSIsInBhcmVudFJ1bklkIiwiZ2V0UGFyZW50UnVuSWQiLCJsYW5nQ2hhaW5UcmFjZXIiLCJoYW5kbGVycyIsImZpbmQiLCJoYW5kbGVyIiwibmFtZSIsImdldFJ1biIsImRlZHVwcGVkVGFncyIsIlNldCIsInRhZ3MiLCJjb25jYXQiLCJkZWR1cGVkTWV0YWRhdGEiLCJleHRyYSIsIm1ldGFkYXRhIiwicnQiLCJwcm9qZWN0X25hbWUiLCJ2NCIsInJ1bl90eXBlIiwiY2hpbGRfcnVucyIsImFwaV91cmwiLCJhcGlfa2V5IiwiY2FsbGVyX29wdGlvbnMiLCJub3ciLCJzZXJpYWxpemVkIiwiaW5wdXRzIiwiY3JlYXRlQ2hpbGQiLCJjaGlsZCIsInB1c2giLCJlbmQiLCJvdXRwdXRzIiwiZXJyb3IiLCJlbmRUaW1lIiwiZW5kX3RpbWUiLCJfY29udmVydFRvQ3JlYXRlIiwicnVuIiwiZXhjbHVkZUNoaWxkUnVucyIsInJ1bkV4dHJhIiwicnVudGltZSIsInJ1bnRpbWVFbnYiLCJrIiwidiIsImVudHJpZXMiLCJwYXJlbnRfcnVuX2lkIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImNoaWxkX3J1biIsInVuZGVmaW5lZCIsInBlcnNpc3RlZFJ1biIsInJlZmVyZW5jZV9leGFtcGxlX2lkIiwic2Vzc2lvbl9uYW1lIiwicG9zdFJ1biIsInJ1bkNyZWF0ZSIsImNyZWF0ZVJ1biIsImNoaWxkUnVuIiwicGF0Y2hSdW4iLCJydW5VcGRhdGUiLCJldmVudHMiLCJ1cGRhdGVSdW4iLCJpc1J1blRyZWUiLCJ4IiwiY29udGFpbnNMYW5nQ2hhaW5UcmFjZXJMaWtlIiwiQXJyYXkiLCJpc0FycmF5Iiwic29tZSIsImNhbGxiYWNrIiwiaXNSdW5uYWJsZUNvbmZpZ0xpa2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/async_caller.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/async_caller.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n\n\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    403,\n    404,\n    405,\n    406,\n    407,\n    408\n];\nconst STATUS_IGNORE = [\n    409\n];\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */ class AsyncCaller {\n    constructor(params){\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        const PQueue =  true ? p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"] : p_queue__WEBPACK_IMPORTED_MODULE_1__;\n        this.queue = new PQueue({\n            concurrency: this.maxConcurrency\n        });\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        const onFailedResponseHook = this.onFailedResponseHook;\n        return this.queue.add(()=>p_retry__WEBPACK_IMPORTED_MODULE_0__(()=>callable(...args).catch((error)=>{\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (error instanceof Error) {\n                        throw error;\n                    } else {\n                        throw new Error(error);\n                    }\n                }), {\n                async onFailedAttempt (error) {\n                    if (error.message.startsWith(\"Cancel\") || error.message.startsWith(\"TimeoutError\") || error.message.startsWith(\"AbortError\")) {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    if (error?.code === \"ECONNABORTED\") {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const response = error?.response;\n                    const status = response?.status;\n                    if (status) {\n                        if (STATUS_NO_RETRY.includes(+status)) {\n                            throw error;\n                        } else if (STATUS_IGNORE.includes(+status)) {\n                            return;\n                        }\n                        if (onFailedResponseHook) {\n                            await onFailedResponseHook(response);\n                        }\n                    }\n                },\n                // If needed we can change some of the defaults here,\n                // but they're quite sensible.\n                retries: this.maxRetries,\n                randomize: true\n            }), {\n            throwOnTimeout: true\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject)=>{\n                    options.signal?.addEventListener(\"abort\", ()=>{\n                        reject(new Error(\"AbortError\"));\n                    });\n                })\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(()=>fetch(...args).then((res)=>res.ok ? res : Promise.reject(res)));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QjtBQUNHO0FBQ2hDLE1BQU1FLGtCQUFrQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxNQUFNQyxnQkFBZ0I7SUFDbEI7Q0FDSDtBQUNEOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLE1BQU1DO0lBQ1RDLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQkMsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxrQkFBa0I7WUFDMUNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLHdCQUF3QjtZQUNoREMsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0EsSUFBSSxDQUFDQyxjQUFjLEdBQUdQLE9BQU9PLGNBQWMsSUFBSUM7UUFDL0MsSUFBSSxDQUFDQyxVQUFVLEdBQUdULE9BQU9TLFVBQVUsSUFBSTtRQUN2QyxNQUFNQyxTQUFTLEtBQXNCZixHQUFHQSwrQ0FBaUIsR0FBR0Esb0NBQVNBO1FBQ3JFLElBQUksQ0FBQ2lCLEtBQUssR0FBRyxJQUFJRixPQUFPO1lBQUVHLGFBQWEsSUFBSSxDQUFDTixjQUFjO1FBQUM7UUFDM0QsSUFBSSxDQUFDTyxvQkFBb0IsR0FBR2QsUUFBUWM7SUFDeEM7SUFDQSw4REFBOEQ7SUFDOURDLEtBQUtDLFFBQVEsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDcEIsTUFBTUgsdUJBQXVCLElBQUksQ0FBQ0Esb0JBQW9CO1FBQ3RELE9BQU8sSUFBSSxDQUFDRixLQUFLLENBQUNNLEdBQUcsQ0FBQyxJQUFNeEIsb0NBQU1BLENBQUMsSUFBTXNCLFlBQVlDLE1BQU1FLEtBQUssQ0FBQyxDQUFDQztvQkFDOUQsdURBQXVEO29CQUN2RCxJQUFJQSxpQkFBaUJDLE9BQU87d0JBQ3hCLE1BQU1EO29CQUNWLE9BQ0s7d0JBQ0QsTUFBTSxJQUFJQyxNQUFNRDtvQkFDcEI7Z0JBQ0osSUFBSTtnQkFDQSxNQUFNRSxpQkFBZ0JGLEtBQUs7b0JBQ3ZCLElBQUlBLE1BQU1HLE9BQU8sQ0FBQ0MsVUFBVSxDQUFDLGFBQ3pCSixNQUFNRyxPQUFPLENBQUNDLFVBQVUsQ0FBQyxtQkFDekJKLE1BQU1HLE9BQU8sQ0FBQ0MsVUFBVSxDQUFDLGVBQWU7d0JBQ3hDLE1BQU1KO29CQUNWO29CQUNBLDhEQUE4RDtvQkFDOUQsSUFBSUEsT0FBT0ssU0FBUyxnQkFBZ0I7d0JBQ2hDLE1BQU1MO29CQUNWO29CQUNBLDhEQUE4RDtvQkFDOUQsTUFBTU0sV0FBV04sT0FBT007b0JBQ3hCLE1BQU1DLFNBQVNELFVBQVVDO29CQUN6QixJQUFJQSxRQUFRO3dCQUNSLElBQUkvQixnQkFBZ0JnQyxRQUFRLENBQUMsQ0FBQ0QsU0FBUzs0QkFDbkMsTUFBTVA7d0JBQ1YsT0FDSyxJQUFJdkIsY0FBYytCLFFBQVEsQ0FBQyxDQUFDRCxTQUFTOzRCQUN0Qzt3QkFDSjt3QkFDQSxJQUFJYixzQkFBc0I7NEJBQ3RCLE1BQU1BLHFCQUFxQlk7d0JBQy9CO29CQUNKO2dCQUNKO2dCQUNBLHFEQUFxRDtnQkFDckQsOEJBQThCO2dCQUM5QkcsU0FBUyxJQUFJLENBQUNwQixVQUFVO2dCQUN4QnFCLFdBQVc7WUFDZixJQUFJO1lBQUVDLGdCQUFnQjtRQUFLO0lBQy9CO0lBQ0EsOERBQThEO0lBQzlEQyxnQkFBZ0JDLE9BQU8sRUFBRWpCLFFBQVEsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDeEMsbURBQW1EO1FBQ25ELHdFQUF3RTtRQUN4RSxJQUFJZ0IsUUFBUUMsTUFBTSxFQUFFO1lBQ2hCLE9BQU9DLFFBQVFDLElBQUksQ0FBQztnQkFDaEIsSUFBSSxDQUFDckIsSUFBSSxDQUFDQyxhQUFhQztnQkFDdkIsSUFBSWtCLFFBQVEsQ0FBQ0UsR0FBR0M7b0JBQ1pMLFFBQVFDLE1BQU0sRUFBRUssaUJBQWlCLFNBQVM7d0JBQ3RDRCxPQUFPLElBQUlqQixNQUFNO29CQUNyQjtnQkFDSjthQUNIO1FBQ0w7UUFDQSxPQUFPLElBQUksQ0FBQ04sSUFBSSxDQUFDQyxhQUFhQztJQUNsQztJQUNBdUIsTUFBTSxHQUFHdkIsSUFBSSxFQUFFO1FBQ1gsT0FBTyxJQUFJLENBQUNGLElBQUksQ0FBQyxJQUFNeUIsU0FBU3ZCLE1BQU13QixJQUFJLENBQUMsQ0FBQ0MsTUFBU0EsSUFBSUMsRUFBRSxHQUFHRCxNQUFNUCxRQUFRRyxNQUFNLENBQUNJO0lBQ3ZGO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1mb3JtLWJ1aWxkZXItdHV0b3JpYWwvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzP2E4ZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBSZXRyeSBmcm9tIFwicC1yZXRyeVwiO1xuaW1wb3J0IFBRdWV1ZU1vZCBmcm9tIFwicC1xdWV1ZVwiO1xuY29uc3QgU1RBVFVTX05PX1JFVFJZID0gW1xuICAgIDQwMCxcbiAgICA0MDEsXG4gICAgNDAzLFxuICAgIDQwNCxcbiAgICA0MDUsXG4gICAgNDA2LFxuICAgIDQwNyxcbiAgICA0MDgsIC8vIFJlcXVlc3QgVGltZW91dFxuXTtcbmNvbnN0IFNUQVRVU19JR05PUkUgPSBbXG4gICAgNDA5LCAvLyBDb25mbGljdFxuXTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgY2FsbHMgd2l0aCBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIG1ha2luZyBjYWxscyB0byBhbnkga2luZCBvZiBcImV4cGVuc2l2ZVwiIGV4dGVybmFsIHJlc291cmNlLFxuICogYmUgaXQgYmVjYXVzZSBpdCdzIHJhdGUtbGltaXRlZCwgc3ViamVjdCB0byBuZXR3b3JrIGlzc3VlcywgZXRjLlxuICpcbiAqIENvbmN1cnJlbnQgY2FsbHMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0c1xuICogdG8gYEluZmluaXR5YC4gVGhpcyBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGFsbCBjYWxscyB3aWxsIGJlIG1hZGUgaW4gcGFyYWxsZWwuXG4gKlxuICogUmV0cmllcyBhcmUgbGltaXRlZCBieSB0aGUgYG1heFJldHJpZXNgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHMgdG8gNi4gVGhpc1xuICogbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBlYWNoIGNhbGwgd2lsbCBiZSByZXRyaWVkIHVwIHRvIDYgdGltZXMsIHdpdGggYW5cbiAqIGV4cG9uZW50aWFsIGJhY2tvZmYgYmV0d2VlbiBlYWNoIGF0dGVtcHQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3luY0NhbGxlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heENvbmN1cnJlbmN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFJldHJpZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25GYWlsZWRSZXNwb25zZUhvb2tcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHBhcmFtcy5tYXhDb25jdXJyZW5jeSA/PyBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcGFyYW1zLm1heFJldHJpZXMgPz8gNjtcbiAgICAgICAgY29uc3QgUFF1ZXVlID0gXCJkZWZhdWx0XCIgaW4gUFF1ZXVlTW9kID8gUFF1ZXVlTW9kLmRlZmF1bHQgOiBQUXVldWVNb2Q7XG4gICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlKHsgY29uY3VycmVuY3k6IHRoaXMubWF4Q29uY3VycmVuY3kgfSk7XG4gICAgICAgIHRoaXMub25GYWlsZWRSZXNwb25zZUhvb2sgPSBwYXJhbXM/Lm9uRmFpbGVkUmVzcG9uc2VIb29rO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgb25GYWlsZWRSZXNwb25zZUhvb2sgPSB0aGlzLm9uRmFpbGVkUmVzcG9uc2VIb29rO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5hZGQoKCkgPT4gcFJldHJ5KCgpID0+IGNhbGxhYmxlKC4uLmFyZ3MpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhc3luYyBvbkZhaWxlZEF0dGVtcHQoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQ2FuY2VsXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIlRpbWVvdXRFcnJvclwiKSB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJBYm9ydEVycm9yXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGlmIChlcnJvcj8uY29kZSA9PT0gXCJFQ09OTkFCT1JURURcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGVycm9yPy5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSByZXNwb25zZT8uc3RhdHVzO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFNUQVRVU19OT19SRVRSWS5pbmNsdWRlcygrc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoU1RBVFVTX0lHTk9SRS5pbmNsdWRlcygrc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkZhaWxlZFJlc3BvbnNlSG9vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgb25GYWlsZWRSZXNwb25zZUhvb2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIElmIG5lZWRlZCB3ZSBjYW4gY2hhbmdlIHNvbWUgb2YgdGhlIGRlZmF1bHRzIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgdGhleSdyZSBxdWl0ZSBzZW5zaWJsZS5cbiAgICAgICAgICAgIHJldHJpZXM6IHRoaXMubWF4UmV0cmllcyxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgfSksIHsgdGhyb3dPblRpbWVvdXQ6IHRydWUgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbFdpdGhPcHRpb25zKG9wdGlvbnMsIGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIE5vdGUgdGhpcyBkb2Vzbid0IGNhbmNlbCB0aGUgdW5kZXJseWluZyByZXF1ZXN0LFxuICAgICAgICAvLyB3aGVuIGF2YWlsYWJsZSBwcmVmZXIgdG8gdXNlIHRoZSBzaWduYWwgb3B0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIGNhbGxcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRFcnJvclwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyk7XG4gICAgfVxuICAgIGZldGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCgoKSA9PiBmZXRjaCguLi5hcmdzKS50aGVuKChyZXMpID0+IChyZXMub2sgPyByZXMgOiBQcm9taXNlLnJlamVjdChyZXMpKSkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJwUmV0cnkiLCJQUXVldWVNb2QiLCJTVEFUVVNfTk9fUkVUUlkiLCJTVEFUVVNfSUdOT1JFIiwiQXN5bmNDYWxsZXIiLCJjb25zdHJ1Y3RvciIsInBhcmFtcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJtYXhDb25jdXJyZW5jeSIsIkluZmluaXR5IiwibWF4UmV0cmllcyIsIlBRdWV1ZSIsImRlZmF1bHQiLCJxdWV1ZSIsImNvbmN1cnJlbmN5Iiwib25GYWlsZWRSZXNwb25zZUhvb2siLCJjYWxsIiwiY2FsbGFibGUiLCJhcmdzIiwiYWRkIiwiY2F0Y2giLCJlcnJvciIsIkVycm9yIiwib25GYWlsZWRBdHRlbXB0IiwibWVzc2FnZSIsInN0YXJ0c1dpdGgiLCJjb2RlIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJpbmNsdWRlcyIsInJldHJpZXMiLCJyYW5kb21pemUiLCJ0aHJvd09uVGltZW91dCIsImNhbGxXaXRoT3B0aW9ucyIsIm9wdGlvbnMiLCJzaWduYWwiLCJQcm9taXNlIiwicmFjZSIsIl8iLCJyZWplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZmV0Y2giLCJ0aGVuIiwicmVzIiwib2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/env.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/env.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getEnvironmentVariables: () => (/* binding */ getEnvironmentVariables),\n/* harmony export */   getLangChainEnvVars: () => (/* binding */ getLangChainEnvVars),\n/* harmony export */   getLangChainEnvVarsMetadata: () => (/* binding */ getLangChainEnvVarsMetadata),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   getShas: () => (/* binding */ getShas),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   setEnvironmentVariable: () => (/* binding */ setEnvironmentVariable)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n// Inlined from https://github.com/flexdinesh/browser-or-node\n\nlet globalEnv;\nconst isBrowser = ()=> false && 0;\nconst isWebWorker = ()=>typeof globalThis === \"object\" && globalThis.constructor && globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = ()=> false || typeof navigator !== \"undefined\" && (navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\"));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = ()=>typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = ()=>typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.node !== \"undefined\" && !isDeno();\nconst getEnv = ()=>{\n    if (globalEnv) {\n        return globalEnv;\n    }\n    if (isBrowser()) {\n        globalEnv = \"browser\";\n    } else if (isNode()) {\n        globalEnv = \"node\";\n    } else if (isWebWorker()) {\n        globalEnv = \"webworker\";\n    } else if (isJsDom()) {\n        globalEnv = \"jsdom\";\n    } else if (isDeno()) {\n        globalEnv = \"deno\";\n    } else {\n        globalEnv = \"other\";\n    }\n    return globalEnv;\n};\nlet runtimeEnvironment;\nasync function getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        const releaseEnv = getShas();\n        runtimeEnvironment = {\n            library: \"langsmith\",\n            runtime: env,\n            sdk: \"langsmith-js\",\n            sdk_version: _index_js__WEBPACK_IMPORTED_MODULE_0__.__version__,\n            ...releaseEnv\n        };\n    }\n    return runtimeEnvironment;\n}\n/**\n * Retrieves the LangChain-specific environment variables from the current runtime environment.\n * Sensitive keys (containing the word \"key\", \"token\", or \"secret\") have their values redacted for security.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific environment variables.\n */ function getLangChainEnvVars() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\") {\n            envVars[key] = value;\n        }\n    }\n    for(const key in envVars){\n        if ((key.toLowerCase().includes(\"key\") || key.toLowerCase().includes(\"secret\") || key.toLowerCase().includes(\"token\")) && typeof envVars[key] === \"string\") {\n            const value = envVars[key];\n            envVars[key] = value.slice(0, 2) + \"*\".repeat(value.length - 4) + value.slice(-2);\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the LangChain-specific metadata from the current runtime environment.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific metadata environment variables.\n */ function getLangChainEnvVarsMetadata() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    const excluded = [\n        \"LANGCHAIN_API_KEY\",\n        \"LANGCHAIN_ENDPOINT\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGCHAIN_PROJECT\",\n        \"LANGCHAIN_SESSION\"\n    ];\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\" && !excluded.includes(key) && !key.toLowerCase().includes(\"key\") && !key.toLowerCase().includes(\"secret\") && !key.toLowerCase().includes(\"token\")) {\n            if (key === \"LANGCHAIN_REVISION_ID\") {\n                envVars[\"revision_id\"] = value;\n            } else {\n                envVars[key] = value;\n            }\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the environment variables from the current runtime environment.\n *\n * This function is designed to operate in a variety of JS environments,\n * including Node.js, Deno, browsers, etc.\n *\n * @returns {Record<string, string> | undefined}\n *  - A record of environment variables if available.\n *  - `undefined` if the environment does not support or allows access to environment variables.\n */ function getEnvironmentVariables() {\n    try {\n        // Check for Node.js environment\n        // eslint-disable-next-line no-process-env\n        if (typeof process !== \"undefined\" && process.env) {\n            // eslint-disable-next-line no-process-env\n            return Object.entries(process.env).reduce((acc, [key, value])=>{\n                acc[key] = String(value);\n                return acc;\n            }, {});\n        }\n        // For browsers and other environments, we may not have direct access to env variables\n        // Return undefined or any other fallback as required.\n        return undefined;\n    } catch (e) {\n        // Catch any errors that might occur while trying to access environment variables\n        return undefined;\n    }\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/hwchase17/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\" ? process.env?.[name] : undefined;\n    } catch (e) {\n        return undefined;\n    }\n}\nfunction setEnvironmentVariable(name, value) {\n    if (typeof process !== \"undefined\") {\n        // eslint-disable-next-line no-process-env\n        process.env[name] = value;\n    }\n}\nlet cachedCommitSHAs;\n/**\n * Get the Git commit SHA from common environment variables\n * used by different CI/CD platforms.\n * @returns {string | undefined} The Git commit SHA or undefined if not found.\n */ function getShas() {\n    if (cachedCommitSHAs !== undefined) {\n        return cachedCommitSHAs;\n    }\n    const common_release_envs = [\n        \"VERCEL_GIT_COMMIT_SHA\",\n        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n        \"COMMIT_REF\",\n        \"RENDER_GIT_COMMIT\",\n        \"CI_COMMIT_SHA\",\n        \"CIRCLE_SHA1\",\n        \"CF_PAGES_COMMIT_SHA\",\n        \"REACT_APP_GIT_SHA\",\n        \"SOURCE_VERSION\",\n        \"GITHUB_SHA\",\n        \"TRAVIS_COMMIT\",\n        \"GIT_COMMIT\",\n        \"BUILD_VCS_NUMBER\",\n        \"bamboo_planRepository_revision\",\n        \"Build.SourceVersion\",\n        \"BITBUCKET_COMMIT\",\n        \"DRONE_COMMIT_SHA\",\n        \"SEMAPHORE_GIT_SHA\",\n        \"BUILDKITE_COMMIT\"\n    ];\n    const shas = {};\n    for (const env of common_release_envs){\n        const envVar = getEnvironmentVariable(env);\n        if (envVar !== undefined) {\n            shas[env] = envVar;\n        }\n    }\n    cachedCommitSHAs = shas;\n    return shas;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkRBQTZEO0FBQ25CO0FBQzFDLElBQUlDO0FBQ0csTUFBTUMsWUFBWSxJQUFNLE1BQTZCLElBQUksQ0FBc0MsQ0FBQztBQUNoRyxNQUFNRyxjQUFjLElBQU0sT0FBT0MsZUFBZSxZQUNuREEsV0FBV0MsV0FBVyxJQUN0QkQsV0FBV0MsV0FBVyxDQUFDQyxJQUFJLEtBQUssNkJBQTZCO0FBQzFELE1BQU1DLFVBQVUsSUFBTSxNQUEwRCxJQUNsRixPQUFPQyxjQUFjLGVBQ2pCQSxDQUFBQSxVQUFVQyxTQUFTLENBQUNDLFFBQVEsQ0FBQyxjQUMxQkYsVUFBVUMsU0FBUyxDQUFDQyxRQUFRLENBQUMsUUFBTyxFQUFJO0FBQ3BELHlEQUF5RDtBQUN6RCw2QkFBNkI7QUFDdEIsTUFBTUMsU0FBUyxJQUFNLE9BQU9DLFNBQVMsWUFBWTtBQUN4RCxnREFBZ0Q7QUFDekMsTUFBTUMsU0FBUyxJQUFNLE9BQU9DLFlBQVksZUFDM0MsT0FBT0EsUUFBUUMsUUFBUSxLQUFLLGVBQzVCLE9BQU9ELFFBQVFDLFFBQVEsQ0FBQ0MsSUFBSSxLQUFLLGVBQ2pDLENBQUNMLFNBQVM7QUFDUCxNQUFNTSxTQUFTO0lBQ2xCLElBQUlsQixXQUFXO1FBQ1gsT0FBT0E7SUFDWDtJQUNBLElBQUlDLGFBQWE7UUFDYkQsWUFBWTtJQUNoQixPQUNLLElBQUljLFVBQVU7UUFDZmQsWUFBWTtJQUNoQixPQUNLLElBQUlJLGVBQWU7UUFDcEJKLFlBQVk7SUFDaEIsT0FDSyxJQUFJUSxXQUFXO1FBQ2hCUixZQUFZO0lBQ2hCLE9BQ0ssSUFBSVksVUFBVTtRQUNmWixZQUFZO0lBQ2hCLE9BQ0s7UUFDREEsWUFBWTtJQUNoQjtJQUNBLE9BQU9BO0FBQ1gsRUFBRTtBQUNGLElBQUltQjtBQUNHLGVBQWVDO0lBQ2xCLElBQUlELHVCQUF1QkUsV0FBVztRQUNs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NEIsdUJBQXVCMUMsSUFBSSxFQUFFMkIsS0FBSztJQUM5QyxJQUFJLE9BQU9uQixZQUFZLGFBQWE7UUFDaEMsMENBQTBDO1FBQzFDQSxRQUFRTyxHQUFHLENBQUNmLEtBQUssR0FBRzJCO0lBQ3hCO0FBQ0o7QUFDQSxJQUFJZ0I7QUFDSjs7OztDQUlDLEdBQ00sU0FBUzFCO0lBQ1osSUFBSTBCLHFCQUFxQjdCLFdBQVc7UUFDaEMsT0FBTzZCO0lBQ1g7SUFDQSxNQUFNQyxzQkFBc0I7UUFDeEI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU1DLE9BQU8sQ0FBQztJQUNkLEtBQUssTUFBTTlCLE9BQU82QixvQkFBcUI7UUFDbkMsTUFBTUUsU0FBU0wsdUJBQXVCMUI7UUFDdEMsSUFBSStCLFdBQVdoQyxXQUFXO1lBQ3RCK0IsSUFBSSxDQUFDOUIsSUFBSSxHQUFHK0I7UUFDaEI7SUFDSjtJQUNBSCxtQkFBbUJFO0lBQ25CLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1mb3JtLWJ1aWxkZXItdHV0b3JpYWwvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzP2E3NDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW5saW5lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mbGV4ZGluZXNoL2Jyb3dzZXItb3Itbm9kZVxuaW1wb3J0IHsgX192ZXJzaW9uX18gfSBmcm9tIFwiLi4vaW5kZXguanNcIjtcbmxldCBnbG9iYWxFbnY7XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZXhwb3J0IGNvbnN0IGlzV2ViV29ya2VyID0gKCkgPT4gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkRlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXCI7XG5leHBvcnQgY29uc3QgaXNKc0RvbSA9ICgpID0+ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYW1lID09PSBcIm5vZGVqc1wiKSB8fFxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTm9kZS5qc1wiKSB8fFxuICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcImpzZG9tXCIpKSk7XG4vLyBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uIHByb3ZpZGVzIGEgYERlbm9gIGdsb2JhbCBvYmplY3Rcbi8vIHdpdGhvdXQgYHZlcnNpb25gIHByb3BlcnR5XG5leHBvcnQgY29uc3QgaXNEZW5vID0gKCkgPT4gdHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCI7XG4vLyBNYXJrIG5vdC1hcy1ub2RlIGlmIGluIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb25cbmV4cG9ydCBjb25zdCBpc05vZGUgPSAoKSA9PiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICFpc0Rlbm8oKTtcbmV4cG9ydCBjb25zdCBnZXRFbnYgPSAoKSA9PiB7XG4gICAgaWYgKGdsb2JhbEVudikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsRW52O1xuICAgIH1cbiAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJicm93c2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwibm9kZVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1dlYldvcmtlcigpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwid2Vid29ya2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSnNEb20oKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImpzZG9tXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVubygpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwiZGVub1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJvdGhlclwiO1xuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsRW52O1xufTtcbmxldCBydW50aW1lRW52aXJvbm1lbnQ7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UnVudGltZUVudmlyb25tZW50KCkge1xuICAgIGlmIChydW50aW1lRW52aXJvbm1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlbnYgPSBnZXRFbnYoKTtcbiAgICAgICAgY29uc3QgcmVsZWFzZUVudiA9IGdldFNoYXMoKTtcbiAgICAgICAgcnVudGltZUVudmlyb25tZW50ID0ge1xuICAgICAgICAgICAgbGlicmFyeTogXCJsYW5nc21pdGhcIixcbiAgICAgICAgICAgIHJ1bnRpbWU6IGVudixcbiAgICAgICAgICAgIHNkazogXCJsYW5nc21pdGgtanNcIixcbiAgICAgICAgICAgIHNka192ZXJzaW9uOiBfX3ZlcnNpb25fXyxcbiAgICAgICAgICAgIC4uLnJlbGVhc2VFbnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBydW50aW1lRW52aXJvbm1lbnQ7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgTGFuZ0NoYWluLXNwZWNpZmljIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKiBTZW5zaXRpdmUga2V5cyAoY29udGFpbmluZyB0aGUgd29yZCBcImtleVwiLCBcInRva2VuXCIsIG9yIFwic2VjcmV0XCIpIGhhdmUgdGhlaXIgdmFsdWVzIHJlZGFjdGVkIGZvciBzZWN1cml0eS5cbiAqXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqICAtIEEgcmVjb3JkIG9mIExhbmdDaGFpbi1zcGVjaWZpYyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5nQ2hhaW5FbnZWYXJzKCkge1xuICAgIGNvbnN0IGFsbEVudlZhcnMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHx8IHt9O1xuICAgIGNvbnN0IGVudlZhcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhbGxFbnZWYXJzKSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJMQU5HQ0hBSU5fXCIpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZW52VmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZW52VmFycykge1xuICAgICAgICBpZiAoKGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpIHx8XG4gICAgICAgICAgICBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInNlY3JldFwiKSB8fFxuICAgICAgICAgICAga2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ0b2tlblwiKSkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBlbnZWYXJzW2tleV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZW52VmFyc1trZXldO1xuICAgICAgICAgICAgZW52VmFyc1trZXldID1cbiAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCAyKSArIFwiKlwiLnJlcGVhdCh2YWx1ZS5sZW5ndGggLSA0KSArIHZhbHVlLnNsaWNlKC0yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBMYW5nQ2hhaW4tc3BlY2lmaWMgbWV0YWRhdGEgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogIC0gQSByZWNvcmQgb2YgTGFuZ0NoYWluLXNwZWNpZmljIG1ldGFkYXRhIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBhbGxFbnZWYXJzID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKSB8fCB7fTtcbiAgICBjb25zdCBlbnZWYXJzID0ge307XG4gICAgY29uc3QgZXhjbHVkZWQgPSBbXG4gICAgICAgIFwiTEFOR0NIQUlOX0FQSV9LRVlcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fVFJBQ0lOR19WMlwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9QUk9KRUNUXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1NFU1NJT05cIixcbiAgICBdO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFsbEVudlZhcnMpKSB7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIkxBTkdDSEFJTl9cIikgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgIWV4Y2x1ZGVkLmluY2x1ZGVzKGtleSkgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImtleVwiKSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic2VjcmV0XCIpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ0b2tlblwiKSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJMQU5HQ0hBSU5fUkVWSVNJT05fSURcIikge1xuICAgICAgICAgICAgICAgIGVudlZhcnNbXCJyZXZpc2lvbl9pZFwiXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW52VmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudlZhcnM7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZyb20gdGhlIGN1cnJlbnQgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIG9wZXJhdGUgaW4gYSB2YXJpZXR5IG9mIEpTIGVudmlyb25tZW50cyxcbiAqIGluY2x1ZGluZyBOb2RlLmpzLCBEZW5vLCBicm93c2VycywgZXRjLlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgdW5kZWZpbmVkfVxuICogIC0gQSByZWNvcmQgb2YgZW52aXJvbm1lbnQgdmFyaWFibGVzIGlmIGF2YWlsYWJsZS5cbiAqICAtIGB1bmRlZmluZWRgIGlmIHRoZSBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IG9yIGFsbG93cyBhY2Nlc3MgdG8gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIE5vZGUuanMgZW52aXJvbm1lbnRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMocHJvY2Vzcy5lbnYpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgYnJvd3NlcnMgYW5kIG90aGVyIGVudmlyb25tZW50cywgd2UgbWF5IG5vdCBoYXZlIGRpcmVjdCBhY2Nlc3MgdG8gZW52IHZhcmlhYmxlc1xuICAgICAgICAvLyBSZXR1cm4gdW5kZWZpbmVkIG9yIGFueSBvdGhlciBmYWxsYmFjayBhcyByZXF1aXJlZC5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQ2F0Y2ggYW55IGVycm9ycyB0aGF0IG1pZ2h0IG9jY3VyIHdoaWxlIHRyeWluZyB0byBhY2Nlc3MgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIC8vIENlcnRhaW4gRGVubyBzZXR1cHMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5IHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaHdjaGFzZTE3L2xhbmdjaGFpbmpzL2lzc3Vlcy8xNDEyXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Py5bbmFtZV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbnZpcm9ubWVudFZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICBwcm9jZXNzLmVudltuYW1lXSA9IHZhbHVlO1xuICAgIH1cbn1cbmxldCBjYWNoZWRDb21taXRTSEFzO1xuLyoqXG4gKiBHZXQgdGhlIEdpdCBjb21taXQgU0hBIGZyb20gY29tbW9uIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogdXNlZCBieSBkaWZmZXJlbnQgQ0kvQ0QgcGxhdGZvcm1zLlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIEdpdCBjb21taXQgU0hBIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFzKCkge1xuICAgIGlmIChjYWNoZWRDb21taXRTSEFzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZENvbW1pdFNIQXM7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbl9yZWxlYXNlX2VudnMgPSBbXG4gICAgICAgIFwiVkVSQ0VMX0dJVF9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiTkVYVF9QVUJMSUNfVkVSQ0VMX0dJVF9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiQ09NTUlUX1JFRlwiLFxuICAgICAgICBcIlJFTkRFUl9HSVRfQ09NTUlUXCIsXG4gICAgICAgIFwiQ0lfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIkNJUkNMRV9TSEExXCIsXG4gICAgICAgIFwiQ0ZfUEFHRVNfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIlJFQUNUX0FQUF9HSVRfU0hBXCIsXG4gICAgICAgIFwiU09VUkNFX1ZFUlNJT05cIixcbiAgICAgICAgXCJHSVRIVUJfU0hBXCIsXG4gICAgICAgIFwiVFJBVklTX0NPTU1JVFwiLFxuICAgICAgICBcIkdJVF9DT01NSVRcIixcbiAgICAgICAgXCJCVUlMRF9WQ1NfTlVNQkVSXCIsXG4gICAgICAgIFwiYmFtYm9vX3BsYW5SZXBvc2l0b3J5X3JldmlzaW9uXCIsXG4gICAgICAgIFwiQnVpbGQuU291cmNlVmVyc2lvblwiLFxuICAgICAgICBcIkJJVEJVQ0tFVF9DT01NSVRcIixcbiAgICAgICAgXCJEUk9ORV9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiU0VNQVBIT1JFX0dJVF9TSEFcIixcbiAgICAgICAgXCJCVUlMREtJVEVfQ09NTUlUXCIsXG4gICAgXTtcbiAgICBjb25zdCBzaGFzID0ge307XG4gICAgZm9yIChjb25zdCBlbnYgb2YgY29tbW9uX3JlbGVhc2VfZW52cykge1xuICAgICAgICBjb25zdCBlbnZWYXIgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGVudik7XG4gICAgICAgIGlmIChlbnZWYXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2hhc1tlbnZdID0gZW52VmFyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhY2hlZENvbW1pdFNIQXMgPSBzaGFzO1xuICAgIHJldHVybiBzaGFzO1xufVxuIl0sIm5hbWVzIjpbIl9fdmVyc2lvbl9fIiwiZ2xvYmFsRW52IiwiaXNCcm93c2VyIiwid2luZG93IiwiZG9jdW1lbnQiLCJpc1dlYldvcmtlciIsImdsb2JhbFRoaXMiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJpc0pzRG9tIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5jbHVkZXMiLCJpc0Rlbm8iLCJEZW5vIiwiaXNOb2RlIiwicHJvY2VzcyIsInZlcnNpb25zIiwibm9kZSIsImdldEVudiIsInJ1bnRpbWVFbnZpcm9ubWVudCIsImdldFJ1bnRpbWVFbnZpcm9ubWVudCIsInVuZGVmaW5lZCIsImVudiIsInJlbGVhc2VFbnYiLCJnZXRTaGFzIiwibGlicmFyeSIsInJ1bnRpbWUiLCJzZGsiLCJzZGtfdmVyc2lvbiIsImdldExhbmdDaGFpbkVudlZhcnMiLCJhbGxFbnZWYXJzIiwiZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMiLCJlbnZWYXJzIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwic3RhcnRzV2l0aCIsInRvTG93ZXJDYXNlIiwic2xpY2UiLCJyZXBlYXQiLCJsZW5ndGgiLCJnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEiLCJleGNsdWRlZCIsInJlZHVjZSIsImFjYyIsIlN0cmluZyIsImUiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwic2V0RW52aXJvbm1lbnRWYXJpYWJsZSIsImNhY2hlZENvbW1pdFNIQXMiLCJjb21tb25fcmVsZWFzZV9lbnZzIiwic2hhcyIsImVudlZhciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/messages.js":
/*!*******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/messages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLangChainMessageToExample: () => (/* binding */ convertLangChainMessageToExample),\n/* harmony export */   isLangChainMessage: () => (/* binding */ isLangChainMessage)\n/* harmony export */ });\nfunction isLangChainMessage(message) {\n    return typeof message?._getType === \"function\";\n}\nfunction convertLangChainMessageToExample(message) {\n    const converted = {\n        type: message._getType(),\n        data: {\n            content: message.content\n        }\n    };\n    // Check for presence of keys in additional_kwargs\n    if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {\n        converted.data.additional_kwargs = {\n            ...message.additional_kwargs\n        };\n    }\n    return converted;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxtQkFBbUJDLE9BQU87SUFDdEMsT0FBTyxPQUFPQSxTQUFTQyxhQUFhO0FBQ3hDO0FBQ08sU0FBU0MsaUNBQWlDRixPQUFPO0lBQ3BELE1BQU1HLFlBQVk7UUFDZEMsTUFBTUosUUFBUUMsUUFBUTtRQUN0QkksTUFBTTtZQUFFQyxTQUFTTixRQUFRTSxPQUFPO1FBQUM7SUFDckM7SUFDQSxrREFBa0Q7SUFDbEQsSUFBSU4sU0FBU08scUJBQ1RDLE9BQU9DLElBQUksQ0FBQ1QsUUFBUU8saUJBQWlCLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ25EUCxVQUFVRSxJQUFJLENBQUNFLGlCQUFpQixHQUFHO1lBQUUsR0FBR1AsUUFBUU8saUJBQWlCO1FBQUM7SUFDdEU7SUFDQSxPQUFPSjtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktZm9ybS1idWlsZGVyLXR1dG9yaWFsLy4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL21lc3NhZ2VzLmpzPzQ3M2EiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzTGFuZ0NoYWluTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlPy5fZ2V0VHlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBjb252ZXJ0ZWQgPSB7XG4gICAgICAgIHR5cGU6IG1lc3NhZ2UuX2dldFR5cGUoKSxcbiAgICAgICAgZGF0YTogeyBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgfSxcbiAgICB9O1xuICAgIC8vIENoZWNrIGZvciBwcmVzZW5jZSBvZiBrZXlzIGluIGFkZGl0aW9uYWxfa3dhcmdzXG4gICAgaWYgKG1lc3NhZ2U/LmFkZGl0aW9uYWxfa3dhcmdzICYmXG4gICAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29udmVydGVkLmRhdGEuYWRkaXRpb25hbF9rd2FyZ3MgPSB7IC4uLm1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbiJdLCJuYW1lcyI6WyJpc0xhbmdDaGFpbk1lc3NhZ2UiLCJtZXNzYWdlIiwiX2dldFR5cGUiLCJjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSIsImNvbnZlcnRlZCIsInR5cGUiLCJkYXRhIiwiY29udGVudCIsImFkZGl0aW9uYWxfa3dhcmdzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/index.js":
/*!*****************************************!*\
  !*** ./node_modules/langsmith/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),\n/* harmony export */   __version__: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.__version__)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1mb3JtLWJ1aWxkZXItdHV0b3JpYWwvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2luZGV4LmpzPzE4MWIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9kaXN0L2luZGV4LmpzJyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/index.js\n");

/***/ })

};
;