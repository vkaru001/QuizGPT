"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/p-queue";
exports.ids = ["vendor-chunks/p-queue"];
exports.modules = {

/***/ "(rsc)/./node_modules/p-queue/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/p-queue/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst EventEmitter = __webpack_require__(/*! eventemitter3 */ \"(rsc)/./node_modules/eventemitter3/index.js\");\nconst p_timeout_1 = __webpack_require__(/*! p-timeout */ \"(rsc)/./node_modules/p-timeout/index.js\");\nconst priority_queue_1 = __webpack_require__(/*! ./priority-queue */ \"(rsc)/./node_modules/p-queue/dist/priority-queue.js\");\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst empty = ()=>{};\nconst timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/ class PQueue extends EventEmitter {\n    constructor(options){\n        var _a, _b, _c, _d;\n        super();\n        this._intervalCount = 0;\n        this._intervalEnd = 0;\n        this._pendingCount = 0;\n        this._resolveEmpty = empty;\n        this._resolveIdle = empty;\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = Object.assign({\n            carryoverConcurrencyCount: false,\n            intervalCap: Infinity,\n            interval: 0,\n            concurrency: Infinity,\n            autoStart: true,\n            queueClass: priority_queue_1.default\n        }, options);\n        if (!(typeof options.intervalCap === \"number\" && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\"}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n        this.emit(\"next\");\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty;\n            this.emit(\"idle\");\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n            } else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(()=>{\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                const job = this._queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit(\"active\");\n                job();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(()=>{\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */ _processQueue() {\n        // eslint-disable-next-line no-empty\n        while(this._tryToStartAnother()){}\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === \"number\" && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */ async add(fn, options = {}) {\n        return new Promise((resolve, reject)=>{\n            const run = async ()=>{\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = this._timeout === undefined && options.timeout === undefined ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === undefined ? this._timeout : options.timeout, ()=>{\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    resolve(await operation);\n                } catch (error) {\n                    reject(error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n            this.emit(\"add\");\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */ async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_)=>this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */ start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */ pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */ clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */ async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise((resolve)=>{\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = ()=>{\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */ async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise((resolve)=>{\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = ()=>{\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue.\n    */ get size() {\n        return this._queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */ sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        return this._queue.filter(options).length;\n    }\n    /**\n    Number of pending promises.\n    */ get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */ get isPaused() {\n        return this._isPaused;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n    /**\n    Set the timeout for future operations.\n    */ set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n}\nexports[\"default\"] = PQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcC1xdWV1ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGVBQWVDLG1CQUFPQSxDQUFDLGtFQUFlO0FBQzVDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDBEQUFXO0FBQ3ZDLE1BQU1FLG1CQUFtQkYsbUJBQU9BLENBQUMsNkVBQWtCO0FBQ25ELGdFQUFnRTtBQUNoRSxNQUFNRyxRQUFRLEtBQVE7QUFDdEIsTUFBTUMsZUFBZSxJQUFJSCxZQUFZSSxZQUFZO0FBQ2pEOztBQUVBLEdBQ0EsTUFBTUMsZUFBZVA7SUFDakJRLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUNoQixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxhQUFhLEdBQUdiO1FBQ3JCLElBQUksQ0FBQ2MsWUFBWSxHQUFHZDtRQUNwQix5RUFBeUU7UUFDekVLLFVBQVViLE9BQU91QixNQUFNLENBQUM7WUFBRUMsMkJBQTJCO1lBQU9DLGFBQWFDO1lBQVVDLFVBQVU7WUFBR0MsYUFBYUY7WUFBVUcsV0FBVztZQUFNQyxZQUFZdkIsaUJBQWlCd0IsT0FBTztRQUFDLEdBQUdsQjtRQUNoTCxJQUFJLENBQUUsUUFBT0EsUUFBUVksV0FBVyxLQUFLLFlBQVlaLFFBQVFZLFdBQVcsSUFBSSxJQUFJO1lBQ3hFLE1BQU0sSUFBSU8sVUFBVSxDQUFDLDZEQUE2RCxFQUFFLENBQUNqQixLQUFLLENBQUNELEtBQUtELFFBQVFZLFdBQVcsTUFBTSxRQUFRWCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdtQixRQUFRLEVBQUMsTUFBTyxRQUFRbEIsT0FBTyxLQUFLLElBQUlBLEtBQUssR0FB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YSxHQUFHO2dCQUNqQnNFO2dCQUNBZjtZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7O0lBSUEsR0FDQSxNQUFNZ0IsU0FBUztRQUNYLGtFQUFrRTtRQUNsRSxJQUFJLElBQUksQ0FBQ3hFLGFBQWEsS0FBSyxLQUFLLElBQUksQ0FBQ3FCLE1BQU0sQ0FBQ3dCLElBQUksS0FBSyxHQUFHO1lBQ3BEO1FBQ0o7UUFDQSxPQUFPLElBQUlVLFFBQVFDLENBQUFBO1lBQ2YsTUFBTWUsa0JBQWtCLElBQUksQ0FBQ3JFLFlBQVk7WUFDekMsSUFBSSxDQUFDQSxZQUFZLEdBQUc7Z0JBQ2hCcUU7Z0JBQ0FmO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7O0lBRUEsR0FDQSxJQUFJWCxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUN4QixNQUFNLENBQUN3QixJQUFJO0lBQzNCO0lBQ0E7Ozs7SUFJQSxHQUNBNEIsT0FBT2hGLE9BQU8sRUFBRTtRQUNaLCtEQUErRDtRQUMvRCxPQUFPLElBQUksQ0FBQzRCLE1BQU0sQ0FBQ3FELE1BQU0sQ0FBQ2pGLFNBQVNrRixNQUFNO0lBQzdDO0lBQ0E7O0lBRUEsR0FDQSxJQUFJQyxVQUFVO1FBQ1YsT0FBTyxJQUFJLENBQUM1RSxhQUFhO0lBQzdCO0lBQ0E7O0lBRUEsR0FDQSxJQUFJNkUsV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDbEQsU0FBUztJQUN6QjtJQUNBLElBQUlILFVBQVU7UUFDVixPQUFPLElBQUksQ0FBQ0QsUUFBUTtJQUN4QjtJQUNBOztJQUVBLEdBQ0EsSUFBSUMsUUFBUXNELFlBQVksRUFBRTtRQUN0QixJQUFJLENBQUN2RCxRQUFRLEdBQUd1RDtJQUNwQjtBQUNKO0FBQ0FoRyxrQkFBZSxHQUFHUyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWZvcm0tYnVpbGRlci10dXRvcmlhbC8uL25vZGVfbW9kdWxlcy9wLXF1ZXVlL2Rpc3QvaW5kZXguanM/N2RlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudGVtaXR0ZXIzXCIpO1xuY29uc3QgcF90aW1lb3V0XzEgPSByZXF1aXJlKFwicC10aW1lb3V0XCIpO1xuY29uc3QgcHJpb3JpdHlfcXVldWVfMSA9IHJlcXVpcmUoXCIuL3ByaW9yaXR5LXF1ZXVlXCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuY29uc3QgZW1wdHkgPSAoKSA9PiB7IH07XG5jb25zdCB0aW1lb3V0RXJyb3IgPSBuZXcgcF90aW1lb3V0XzEuVGltZW91dEVycm9yKCk7XG4vKipcblByb21pc2UgcXVldWUgd2l0aCBjb25jdXJyZW5jeSBjb250cm9sLlxuKi9cbmNsYXNzIFBRdWV1ZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ludGVydmFsQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbEVuZCA9IDA7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eSA9IGVtcHR5O1xuICAgICAgICB0aGlzLl9yZXNvbHZlSWRsZSA9IGVtcHR5O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zXG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY2FycnlvdmVyQ29uY3VycmVuY3lDb3VudDogZmFsc2UsIGludGVydmFsQ2FwOiBJbmZpbml0eSwgaW50ZXJ2YWw6IDAsIGNvbmN1cnJlbmN5OiBJbmZpbml0eSwgYXV0b1N0YXJ0OiB0cnVlLCBxdWV1ZUNsYXNzOiBwcmlvcml0eV9xdWV1ZV8xLmRlZmF1bHQgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghKHR5cGVvZiBvcHRpb25zLmludGVydmFsQ2FwID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLmludGVydmFsQ2FwID49IDEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBpbnRlcnZhbENhcFxcYCB0byBiZSBhIG51bWJlciBmcm9tIDEgYW5kIHVwLCBnb3QgXFxgJHsoX2IgPSAoX2EgPSBvcHRpb25zLmludGVydmFsQ2FwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyd9XFxgICgke3R5cGVvZiBvcHRpb25zLmludGVydmFsQ2FwfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnRlcnZhbCA9PT0gdW5kZWZpbmVkIHx8ICEoTnVtYmVyLmlzRmluaXRlKG9wdGlvbnMuaW50ZXJ2YWwpICYmIG9wdGlvbnMuaW50ZXJ2YWwgPj0gMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGludGVydmFsXFxgIHRvIGJlIGEgZmluaXRlIG51bWJlciA+PSAwLCBnb3QgXFxgJHsoX2QgPSAoX2MgPSBvcHRpb25zLmludGVydmFsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJyd9XFxgICgke3R5cGVvZiBvcHRpb25zLmludGVydmFsfSlgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50ID0gb3B0aW9ucy5jYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50O1xuICAgICAgICB0aGlzLl9pc0ludGVydmFsSWdub3JlZCA9IG9wdGlvbnMuaW50ZXJ2YWxDYXAgPT09IEluZmluaXR5IHx8IG9wdGlvbnMuaW50ZXJ2YWwgPT09IDA7XG4gICAgICAgIHRoaXMuX2ludGVydmFsQ2FwID0gb3B0aW9ucy5pbnRlcnZhbENhcDtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBvcHRpb25zLmludGVydmFsO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBvcHRpb25zLnF1ZXVlQ2xhc3MoKTtcbiAgICAgICAgdGhpcy5fcXVldWVDbGFzcyA9IG9wdGlvbnMucXVldWVDbGFzcztcbiAgICAgICAgdGhpcy5jb25jdXJyZW5jeSA9IG9wdGlvbnMuY29uY3VycmVuY3k7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgIHRoaXMuX3Rocm93T25UaW1lb3V0ID0gb3B0aW9ucy50aHJvd09uVGltZW91dCA9PT0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBvcHRpb25zLmF1dG9TdGFydCA9PT0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBfZG9lc0ludGVydmFsQWxsb3dBbm90aGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNJbnRlcnZhbElnbm9yZWQgfHwgdGhpcy5faW50ZXJ2YWxDb3VudCA8IHRoaXMuX2ludGVydmFsQ2FwO1xuICAgIH1cbiAgICBnZXQgX2RvZXNDb25jdXJyZW50QWxsb3dBbm90aGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50IDwgdGhpcy5fY29uY3VycmVuY3k7XG4gICAgfVxuICAgIF9uZXh0KCkge1xuICAgICAgICB0aGlzLl9wZW5kaW5nQ291bnQtLTtcbiAgICAgICAgdGhpcy5fdHJ5VG9TdGFydEFub3RoZXIoKTtcbiAgICAgICAgdGhpcy5lbWl0KCduZXh0Jyk7XG4gICAgfVxuICAgIF9yZXNvbHZlUHJvbWlzZXMoKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eSgpO1xuICAgICAgICB0aGlzLl9yZXNvbHZlRW1wdHkgPSBlbXB0eTtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUlkbGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVJZGxlID0gZW1wdHk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2lkbGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25SZXN1bWVJbnRlcnZhbCgpIHtcbiAgICAgICAgdGhpcy5fb25JbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplSW50ZXJ2YWxJZk5lZWRlZCgpO1xuICAgICAgICB0aGlzLl90aW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIF9pc0ludGVydmFsUGF1c2VkKCkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMuX2ludGVydmFsRW5kIC0gbm93O1xuICAgICAgICAgICAgaWYgKGRlbGF5IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIEFjdCBhcyB0aGUgaW50ZXJ2YWwgd2FzIGRvbmVcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlc3VtZSBpdCBoZXJlIGJlY2F1c2UgaXQgd2lsbCBiZSByZXN1bWVkIG9uIGxpbmUgMTYwXG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxDb3VudCA9ICh0aGlzLl9jYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50KSA/IHRoaXMuX3BlbmRpbmdDb3VudCA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBY3QgYXMgdGhlIGludGVydmFsIGlzIHBlbmRpbmdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGltZW91dElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblJlc3VtZUludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfdHJ5VG9TdGFydEFub3RoZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4gY2xlYXIgdGhlIGludGVydmFsIChcInBhdXNlXCIpXG4gICAgICAgICAgICAvLyBCZWNhdXNlIHdlIGNhbiByZWRvIGl0IGxhdGVyIChcInJlc3VtZVwiKVxuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVydmFsSWQpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVQcm9taXNlcygpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbkluaXRpYWxpemVJbnRlcnZhbCA9ICF0aGlzLl9pc0ludGVydmFsUGF1c2VkKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZG9lc0ludGVydmFsQWxsb3dBbm90aGVyICYmIHRoaXMuX2RvZXNDb25jdXJyZW50QWxsb3dBbm90aGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9iID0gdGhpcy5fcXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgICAgIGlmICgham9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICBqb2IoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuSW5pdGlhbGl6ZUludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbnRlcnZhbElmTmVlZGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2luaXRpYWxpemVJbnRlcnZhbElmTmVlZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNJbnRlcnZhbElnbm9yZWQgfHwgdGhpcy5faW50ZXJ2YWxJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29uSW50ZXJ2YWwoKTtcbiAgICAgICAgfSwgdGhpcy5faW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbEVuZCA9IERhdGUubm93KCkgKyB0aGlzLl9pbnRlcnZhbDtcbiAgICB9XG4gICAgX29uSW50ZXJ2YWwoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcnZhbENvdW50ID09PSAwICYmIHRoaXMuX3BlbmRpbmdDb3VudCA9PT0gMCAmJiB0aGlzLl9pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcnZhbENvdW50ID0gdGhpcy5fY2FycnlvdmVyQ29uY3VycmVuY3lDb3VudCA/IHRoaXMuX3BlbmRpbmdDb3VudCA6IDA7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeGVjdXRlcyBhbGwgcXVldWVkIGZ1bmN0aW9ucyB1bnRpbCBpdCByZWFjaGVzIHRoZSBsaW1pdC5cbiAgICAqL1xuICAgIF9wcm9jZXNzUXVldWUoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICB3aGlsZSAodGhpcy5fdHJ5VG9TdGFydEFub3RoZXIoKSkgeyB9XG4gICAgfVxuICAgIGdldCBjb25jdXJyZW5jeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmN1cnJlbmN5O1xuICAgIH1cbiAgICBzZXQgY29uY3VycmVuY3kobmV3Q29uY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIG5ld0NvbmN1cnJlbmN5ID09PSAnbnVtYmVyJyAmJiBuZXdDb25jdXJyZW5jeSA+PSAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgY29uY3VycmVuY3lcXGAgdG8gYmUgYSBudW1iZXIgZnJvbSAxIGFuZCB1cCwgZ290IFxcYCR7bmV3Q29uY3VycmVuY3l9XFxgICgke3R5cGVvZiBuZXdDb25jdXJyZW5jeX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uY3VycmVuY3kgPSBuZXdDb25jdXJyZW5jeTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZHMgYSBzeW5jIG9yIGFzeW5jIHRhc2sgdG8gdGhlIHF1ZXVlLiBBbHdheXMgcmV0dXJucyBhIHByb21pc2UuXG4gICAgKi9cbiAgICBhc3luYyBhZGQoZm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcnVuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCsrO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVydmFsQ291bnQrKztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSAodGhpcy5fdGltZW91dCA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudGltZW91dCA9PT0gdW5kZWZpbmVkKSA/IGZuKCkgOiBwX3RpbWVvdXRfMS5kZWZhdWx0KFByb21pc2UucmVzb2x2ZShmbigpKSwgKG9wdGlvbnMudGltZW91dCA9PT0gdW5kZWZpbmVkID8gdGhpcy5fdGltZW91dCA6IG9wdGlvbnMudGltZW91dCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRocm93T25UaW1lb3V0ID09PSB1bmRlZmluZWQgPyB0aGlzLl90aHJvd09uVGltZW91dCA6IG9wdGlvbnMudGhyb3dPblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QodGltZW91dEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGF3YWl0IG9wZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fcXVldWUuZW5xdWV1ZShydW4sIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fdHJ5VG9TdGFydEFub3RoZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnYWRkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBTYW1lIGFzIGAuYWRkKClgLCBidXQgYWNjZXB0cyBhbiBhcnJheSBvZiBzeW5jIG9yIGFzeW5jIGZ1bmN0aW9ucy5cblxuICAgIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGZ1bmN0aW9ucyBhcmUgcmVzb2x2ZWQuXG4gICAgKi9cbiAgICBhc3luYyBhZGRBbGwoZnVuY3Rpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChmdW5jdGlvbnMubWFwKGFzeW5jIChmdW5jdGlvbl8pID0+IHRoaXMuYWRkKGZ1bmN0aW9uXywgb3B0aW9ucykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgKG9yIHJlc3VtZSkgZXhlY3V0aW5nIGVucXVldWVkIHRhc2tzIHdpdGhpbiBjb25jdXJyZW5jeSBsaW1pdC4gTm8gbmVlZCB0byBjYWxsIHRoaXMgaWYgcXVldWUgaXMgbm90IHBhdXNlZCAodmlhIGBvcHRpb25zLmF1dG9TdGFydCA9IGZhbHNlYCBvciBieSBgLnBhdXNlKClgIG1ldGhvZC4pXG4gICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBQdXQgcXVldWUgZXhlY3V0aW9uIG9uIGhvbGQuXG4gICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBDbGVhciB0aGUgcXVldWUuXG4gICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgdGhpcy5fcXVldWVDbGFzcygpO1xuICAgIH1cbiAgICAvKipcbiAgICBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLiBVc2VmdWwgaWYgeW91IGZvciBleGFtcGxlIGFkZCBhZGRpdGlvbmFsIGl0ZW1zIGF0IGEgbGF0ZXIgdGltZS5cblxuICAgIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHNldHRsZXMgd2hlbiB0aGUgcXVldWUgYmVjb21lcyBlbXB0eS5cbiAgICAqL1xuICAgIGFzeW5jIG9uRW1wdHkoKSB7XG4gICAgICAgIC8vIEluc3RhbnRseSByZXNvbHZlIGlmIHRoZSBxdWV1ZSBpcyBlbXB0eVxuICAgICAgICBpZiAodGhpcy5fcXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUmVzb2x2ZSA9IHRoaXMuX3Jlc29sdmVFbXB0eTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRpZmZlcmVuY2Ugd2l0aCBgLm9uRW1wdHlgIGlzIHRoYXQgYC5vbklkbGVgIGd1YXJhbnRlZXMgdGhhdCBhbGwgd29yayBmcm9tIHRoZSBxdWV1ZSBoYXMgZmluaXNoZWQuIGAub25FbXB0eWAgbWVyZWx5IHNpZ25hbHMgdGhhdCB0aGUgcXVldWUgaXMgZW1wdHksIGJ1dCBpdCBjb3VsZCBtZWFuIHRoYXQgc29tZSBwcm9taXNlcyBoYXZlbid0IGNvbXBsZXRlZCB5ZXQuXG5cbiAgICBAcmV0dXJucyBBIHByb21pc2UgdGhhdCBzZXR0bGVzIHdoZW4gdGhlIHF1ZXVlIGJlY29tZXMgZW1wdHksIGFuZCBhbGwgcHJvbWlzZXMgaGF2ZSBjb21wbGV0ZWQ7IGBxdWV1ZS5zaXplID09PSAwICYmIHF1ZXVlLnBlbmRpbmcgPT09IDBgLlxuICAgICovXG4gICAgYXN5bmMgb25JZGxlKCkge1xuICAgICAgICAvLyBJbnN0YW50bHkgcmVzb2x2ZSBpZiBub25lIHBlbmRpbmcgYW5kIGlmIG5vdGhpbmcgZWxzZSBpcyBxdWV1ZWRcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb3VudCA9PT0gMCAmJiB0aGlzLl9xdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSZXNvbHZlID0gdGhpcy5fcmVzb2x2ZUlkbGU7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlSWRsZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2l6ZSBvZiB0aGUgcXVldWUuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlLnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFNpemUgb2YgdGhlIHF1ZXVlLCBmaWx0ZXJlZCBieSB0aGUgZ2l2ZW4gb3B0aW9ucy5cblxuICAgIEZvciBleGFtcGxlLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlIG51bWJlciBvZiBpdGVtcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlIHdpdGggYSBzcGVjaWZpYyBwcmlvcml0eSBsZXZlbC5cbiAgICAqL1xuICAgIHNpemVCeShvcHRpb25zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWZuLXJlZmVyZW5jZS1pbi1pdGVyYXRvclxuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuZmlsdGVyKG9wdGlvbnMpLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgTnVtYmVyIG9mIHBlbmRpbmcgcHJvbWlzZXMuXG4gICAgKi9cbiAgICBnZXQgcGVuZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgcXVldWUgaXMgY3VycmVudGx5IHBhdXNlZC5cbiAgICAqL1xuICAgIGdldCBpc1BhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGF1c2VkO1xuICAgIH1cbiAgICBnZXQgdGltZW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgdGltZW91dCBmb3IgZnV0dXJlIG9wZXJhdGlvbnMuXG4gICAgKi9cbiAgICBzZXQgdGltZW91dChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG1pbGxpc2Vjb25kcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQUXVldWU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwicF90aW1lb3V0XzEiLCJwcmlvcml0eV9xdWV1ZV8xIiwiZW1wdHkiLCJ0aW1lb3V0RXJyb3IiLCJUaW1lb3V0RXJyb3IiLCJQUXVldWUiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9pbnRlcnZhbENvdW50IiwiX2ludGVydmFsRW5kIiwiX3BlbmRpbmdDb3VudCIsIl9yZXNvbHZlRW1wdHkiLCJfcmVzb2x2ZUlkbGUiLCJhc3NpZ24iLCJjYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50IiwiaW50ZXJ2YWxDYXAiLCJJbmZpbml0eSIsImludGVydmFsIiwiY29uY3VycmVuY3kiLCJhdXRvU3RhcnQiLCJxdWV1ZUNsYXNzIiwiZGVmYXVsdCIsIlR5cGVFcnJvciIsInRvU3RyaW5nIiwidW5kZWZpbmVkIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJfY2FycnlvdmVyQ29uY3VycmVuY3lDb3VudCIsIl9pc0ludGVydmFsSWdub3JlZCIsIl9pbnRlcnZhbENhcCIsIl9pbnRlcnZhbCIsIl9xdWV1ZSIsIl9xdWV1ZUNsYXNzIiwiX3RpbWVvdXQiLCJ0aW1lb3V0IiwiX3Rocm93T25UaW1lb3V0IiwidGhyb3dPblRpbWVvdXQiLCJfaXNQYXVzZWQiLCJfZG9lc0ludGVydmFsQWxsb3dBbm90aGVyIiwiX2RvZXNDb25jdXJyZW50QWxsb3dBbm90aGVyIiwiX2NvbmN1cnJlbmN5IiwiX25leHQiLCJfdHJ5VG9TdGFydEFub3RoZXIiLCJlbWl0IiwiX3Jlc29sdmVQcm9taXNlcyIsIl9vblJlc3VtZUludGVydmFsIiwiX29uSW50ZXJ2YWwiLCJfaW5pdGlhbGl6ZUludGVydmFsSWZOZWVkZWQiLCJfdGltZW91dElkIiwiX2lzSW50ZXJ2YWxQYXVzZWQiLCJub3ciLCJEYXRlIiwiX2ludGVydmFsSWQiLCJkZWxheSIsInNldFRpbWVvdXQiLCJzaXplIiwiY2xlYXJJbnRlcnZhbCIsImNhbkluaXRpYWxpemVJbnRlcnZhbCIsImpvYiIsImRlcXVldWUiLCJzZXRJbnRlcnZhbCIsIl9wcm9jZXNzUXVldWUiLCJuZXdDb25jdXJyZW5jeSIsImFkZCIsImZuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJydW4iLCJvcGVyYXRpb24iLCJlcnJvciIsImVucXVldWUiLCJhZGRBbGwiLCJmdW5jdGlvbnMiLCJhbGwiLCJtYXAiLCJmdW5jdGlvbl8iLCJzdGFydCIsInBhdXNlIiwiY2xlYXIiLCJvbkVtcHR5IiwiZXhpc3RpbmdSZXNvbHZlIiwib25JZGxlIiwic2l6ZUJ5IiwiZmlsdGVyIiwibGVuZ3RoIiwicGVuZGluZyIsImlzUGF1c2VkIiwibWlsbGlzZWNvbmRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/p-queue/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/p-queue/dist/lower-bound.js":
/*!**************************************************!*\
  !*** ./node_modules/p-queue/dist/lower-bound.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nfunction lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while(count > 0){\n        const step = count / 2 | 0;\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        } else {\n            count = step;\n        }\n    }\n    return first;\n}\nexports[\"default\"] = lowerBound;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcC1xdWV1ZS9kaXN0L2xvd2VyLWJvdW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELG1GQUFtRjtBQUNuRix1RUFBdUU7QUFDdkUsU0FBU0MsV0FBV0MsS0FBSyxFQUFFRixLQUFLLEVBQUVHLFVBQVU7SUFDeEMsSUFBSUMsUUFBUTtJQUNaLElBQUlDLFFBQVFILE1BQU1JLE1BQU07SUFDeEIsTUFBT0QsUUFBUSxFQUFHO1FBQ2QsTUFBTUUsT0FBTyxRQUFTLElBQUs7UUFDM0IsSUFBSUMsS0FBS0osUUFBUUc7UUFDakIsSUFBSUosV0FBV0QsS0FBSyxDQUFDTSxHQUFHLEVBQUVSLFVBQVUsR0FBRztZQUNuQ0ksUUFBUSxFQUFFSTtZQUNWSCxTQUFTRSxPQUFPO1FBQ3BCLE9BQ0s7WUFDREYsUUFBUUU7UUFDWjtJQUNKO0lBQ0EsT0FBT0g7QUFDWDtBQUNBTCxrQkFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWZvcm0tYnVpbGRlci10dXRvcmlhbC8uL25vZGVfbW9kdWxlcy9wLXF1ZXVlL2Rpc3QvbG93ZXItYm91bmQuanM/NDdlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIFBvcnQgb2YgbG93ZXJfYm91bmQgZnJvbSBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvYWxnb3JpdGhtL2xvd2VyX2JvdW5kXG4vLyBVc2VkIHRvIGNvbXB1dGUgaW5zZXJ0aW9uIGluZGV4IHRvIGtlZXAgcXVldWUgc29ydGVkIGFmdGVyIGluc2VydGlvblxuZnVuY3Rpb24gbG93ZXJCb3VuZChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICBsZXQgZmlyc3QgPSAwO1xuICAgIGxldCBjb3VudCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSAoY291bnQgLyAyKSB8IDA7XG4gICAgICAgIGxldCBpdCA9IGZpcnN0ICsgc3RlcDtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaXRdLCB2YWx1ZSkgPD0gMCkge1xuICAgICAgICAgICAgZmlyc3QgPSArK2l0O1xuICAgICAgICAgICAgY291bnQgLT0gc3RlcCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3VudCA9IHN0ZXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gbG93ZXJCb3VuZDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImxvd2VyQm91bmQiLCJhcnJheSIsImNvbXBhcmF0b3IiLCJmaXJzdCIsImNvdW50IiwibGVuZ3RoIiwic3RlcCIsIml0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/p-queue/dist/lower-bound.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/p-queue/dist/priority-queue.js":
/*!*****************************************************!*\
  !*** ./node_modules/p-queue/dist/priority-queue.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst lower_bound_1 = __webpack_require__(/*! ./lower-bound */ \"(rsc)/./node_modules/p-queue/dist/lower-bound.js\");\nclass PriorityQueue {\n    constructor(){\n        this._queue = [];\n    }\n    enqueue(run, options) {\n        options = Object.assign({\n            priority: 0\n        }, options);\n        const element = {\n            priority: options.priority,\n            run\n        };\n        if (this.size && this._queue[this.size - 1].priority >= options.priority) {\n            this._queue.push(element);\n            return;\n        }\n        const index = lower_bound_1.default(this._queue, element, (a, b)=>b.priority - a.priority);\n        this._queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this._queue.shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return this._queue.filter((element)=>element.priority === options.priority).map((element)=>element.run);\n    }\n    get size() {\n        return this._queue.length;\n    }\n}\nexports[\"default\"] = PriorityQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcC1xdWV1ZS9kaXN0L3ByaW9yaXR5LXF1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGdCQUFnQkMsbUJBQU9BLENBQUMsdUVBQWU7QUFDN0MsTUFBTUM7SUFDRkMsYUFBYztRQUNWLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEVBQUU7SUFDcEI7SUFDQUMsUUFBUUMsR0FBRyxFQUFFQyxPQUFPLEVBQUU7UUFDbEJBLFVBQVVYLE9BQU9ZLE1BQU0sQ0FBQztZQUFFQyxVQUFVO1FBQUUsR0FBR0Y7UUFDekMsTUFBTUcsVUFBVTtZQUNaRCxVQUFVRixRQUFRRSxRQUFRO1lBQzFCSDtRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUNLLElBQUksSUFBSSxJQUFJLENBQUNQLE1BQU0sQ0FBQyxJQUFJLENBQUNPLElBQUksR0FBRyxFQUFFLENBQUNGLFFBQVEsSUFBSUYsUUFBUUUsUUFBUSxFQUFFO1lBQ3RFLElBQUksQ0FBQ0wsTUFBTSxDQUFDUSxJQUFJLENBQUNGO1lBQ2pCO1FBQ0o7UUFDQSxNQUFNRyxRQUFRYixjQUFjYyxPQUFPLENBQUMsSUFBSSxDQUFDVixNQUFNLEVBQUVNLFNBQVMsQ0FBQ0ssR0FBR0MsSUFBTUEsRUFBRVAsUUFBUSxHQUFHTSxFQUFFTixRQUFRO1FBQzNGLElBQUksQ0FBQ0wsTUFBTSxDQUFDYSxNQUFNLENBQUNKLE9BQU8sR0FBR0g7SUFDakM7SUFDQVEsVUFBVTtRQUNOLE1BQU1DLE9BQU8sSUFBSSxDQUFDZixNQUFNLENBQUNnQixLQUFLO1FBQzlCLE9BQU9ELFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLYixHQUFHO0lBQy9EO0lBQ0FlLE9BQU9kLE9BQU8sRUFBRTtRQUNaLE9BQU8sSUFBSSxDQUFDSCxNQUFNLENBQUNpQixNQUFNLENBQUMsQ0FBQ1gsVUFBWUEsUUFBUUQsUUFBUSxLQUFLRixRQUFRRSxRQUFRLEVBQUVhLEdBQUcsQ0FBQyxDQUFDWixVQUFZQSxRQUFRSixHQUFHO0lBQzlHO0lBQ0EsSUFBSUssT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDUCxNQUFNLENBQUNtQixNQUFNO0lBQzdCO0FBQ0o7QUFDQXpCLGtCQUFlLEdBQUdJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktZm9ybS1idWlsZGVyLXR1dG9yaWFsLy4vbm9kZV9tb2R1bGVzL3AtcXVldWUvZGlzdC9wcmlvcml0eS1xdWV1ZS5qcz9hNzczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbG93ZXJfYm91bmRfMSA9IHJlcXVpcmUoXCIuL2xvd2VyLWJvdW5kXCIpO1xuY2xhc3MgUHJpb3JpdHlRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgfVxuICAgIGVucXVldWUocnVuLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgcHJpb3JpdHk6IDAgfSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB7XG4gICAgICAgICAgICBwcmlvcml0eTogb3B0aW9ucy5wcmlvcml0eSxcbiAgICAgICAgICAgIHJ1blxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zaXplICYmIHRoaXMuX3F1ZXVlW3RoaXMuc2l6ZSAtIDFdLnByaW9yaXR5ID49IG9wdGlvbnMucHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSBsb3dlcl9ib3VuZF8xLmRlZmF1bHQodGhpcy5fcXVldWUsIGVsZW1lbnQsIChhLCBiKSA9PiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnNwbGljZShpbmRleCwgMCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGRlcXVldWUoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gbnVsbCB8fCBpdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtLnJ1bjtcbiAgICB9XG4gICAgZmlsdGVyKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmZpbHRlcigoZWxlbWVudCkgPT4gZWxlbWVudC5wcmlvcml0eSA9PT0gb3B0aW9ucy5wcmlvcml0eSkubWFwKChlbGVtZW50KSA9PiBlbGVtZW50LnJ1bik7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUubGVuZ3RoO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFByaW9yaXR5UXVldWU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJsb3dlcl9ib3VuZF8xIiwicmVxdWlyZSIsIlByaW9yaXR5UXVldWUiLCJjb25zdHJ1Y3RvciIsIl9xdWV1ZSIsImVucXVldWUiLCJydW4iLCJvcHRpb25zIiwiYXNzaWduIiwicHJpb3JpdHkiLCJlbGVtZW50Iiwic2l6ZSIsInB1c2giLCJpbmRleCIsImRlZmF1bHQiLCJhIiwiYiIsInNwbGljZSIsImRlcXVldWUiLCJpdGVtIiwic2hpZnQiLCJmaWx0ZXIiLCJtYXAiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/p-queue/dist/priority-queue.js\n");

/***/ })

};
;